{Application 'CHOC_NATUREL' logic file generated by CSPro}
PROC GLOBAL

set explicit;
{ Definitions of working variables }
array alpha(8) KishGrid(10);	   { Grid used for selection of child for child discipline module }
alpha(26) alphavar;				   { Alpha working variable used in checking alpha vars }
alpha(26) alphanew;                { Alpha working variable used in checking alpha vars }
alpha(62) alphalst;                { The alphabet }
array codes(50);                   { Array used for creating line numbers of household members sleeping under mosquito net}
array alpha(50) labels(50);        { Array used for creating names of household members sleeping under mosquito net} 
alpha(40) yname, ynamehh, tmpname; { List of names for questions }
alpha(900) strnotes;               { for editnote at the end of the interview }
alpha(40) worklabel;               { Alpha variable to get customize text for questions }

numeric   hhn,xintnum,xsupnum,xmodcent ;

numeric cl;
numeric TOTPRIM,maxmain,MOMIN,MOMAX  maxdep ;
numeric threelastyear lib;
numeric addmode i cln  hhnum x j ;
string strpart dmois xmois xunite libelle ;
string lib_mois mois_prec;

file FichSaPart ;

// sauvegarde des données 
Function sav()
	savepartial();
end;

// Quitter
Function quitter()
	savepartial();
	stop(1) ;
end;

{ User defined functions }

  function showCalc()
    execsystem("calc");
  end;

  { setup basic user bar }
  function userbase();
    userbar( clear );
  
    userbar(add text,"ECVM: MOD 18 ");
	userbar(set color,236,254,255);
	
    userbar( add button, "<",    do("PreviousField") );
    userbar( add button, ">",    do("NextField") );
    userbar( add button, ">>|",  do("AdvanceToEnd") );
    userbar( add button, "Note", do("EditNote") );
    userbar( add button, "Lang", do("ChangeLanguage") );
    userbar( add button, "Calc", showCalc );	
    
 	userbar(add spacing,25);   
	userbar(add button,"Sauvegarde", sav());    
	userbar(add spacing,25);
	userbar(add text," ");
	
	userbar(add button,"Quitter", quitter());    
	userbar(add spacing,25);
	userbar(add text," ");
  end;
  
{ --------------------------------------------------------------------------- }
{ valid
  Checks that a variable has a valid value.
  A valid value is less than 96 and not a special value e.g notappl/missing
  Returns: 1 if valid, 0 if not valid                                        }

function valid(xvar);
  valid = (!special(xvar) and xvar < 96)
end;

{ -------------------------------------------------------------------------- }
{ NAtoZero
  Converts notappl (and 99 - for child labour module) values to zero while not changing other values.
  Returns: 0 if input variable is notappl, else returns it unchanged         }
function NAtoZero(xvar);
  if xvar = notappl or xvar=99 then
    xvar = 0
  endif;
  NAtoZero = xvar;
end;

{ clear_labels
Set value labels for certain questions where the response categories can change }
function clear_labels();
	do i = 1 while i <= 50
	  codes(i) = notappl;
	  labels(i) = "";
	enddo;
end;

//------------------------------------------------------------------------------------------------------------------------
function last();
threelastyear = sysdate("YYYY") - 3;
lib = sysdate("MM")-1;
	if lib=1 	then mois_prec	= "Janvier" 	endif;
	if lib=2 	then mois_prec	= "Février" 	endif;
	if lib=3 	then mois_prec	= "Mars" 		endif;
	if lib=4 	then mois_prec	= "Avril" 		endif;
	if lib=5 	then mois_prec	= "Mai" 		endif;
	if lib=6 	then mois_prec	= "Juin" 		endif;
	if lib=7 	then mois_prec	= "Juillet" 	endif;
	if lib=8 	then mois_prec	= "Août" 		endif;
	if lib=9 	then mois_prec	= "Septembre" 	endif;
	if lib=10 	then mois_prec	= "Octobre" 	endif;
	if lib=11 	then mois_prec	= "Novembre" 	endif;
	if lib=12 	then mois_prec	= "Decembre" 	endif;
end;
//------------------------------------------------------------------------------------------------------------------------

//--------------------------------------------------------------------------------------------------------------------
	function fcmois();
	clear_labels();
		do varying i=1 until i > sysdate( "MM" )
		codes(i)=i; 
			if i=1 then labels(i)= "Janvier" endif;
			if i=2 then labels(i)= "Février" endif;
			if i=3 then labels(i)= "Mars" endif;
			if i=4 then labels(i)= "Avril" endif;
			if i=5 then labels(i)= "Mai" endif;
			if i=6 then labels(i)= "Juin" endif;
			if i=7 then labels(i)= "Juillet" endif;
			if i=8 then labels(i)= "Août" endif;
			if i=9 then labels(i)= "Septembre" endif;
			if i=10 then labels(i)= "Octobre" endif;
			if i=11 then labels(i)= "Novembre" endif;
			if i=12 then labels(i)= "Decembre" endif;
		enddo;
	end;
//--------------------------------------------------------------------------------------------------------------------
	{function choc();
	clear_labels();

    numeric chocSelect = showarray(TabChoc,
                title("Code","Libelle"));
	end;}
//=================================================================================	
	function fcjours();
	clear_labels();
	do varying i=1 until i > sysdate( "DD" )
	codes(i)=i;  labels(i)= edit("99",i);
	
	enddo;
	end;

//================================================================================================================

//Setting a variable value for the currently loaded task
  function setTaskVar(string varName, string varValue)
    //first checking if the variable is already set
    for i in TASKS.TASK_VARIABLES do
      if toupper(strip(varName)) = toupper(strip(TASK_VARNAME(i))) then
	    TASK_VARVAL(i) = varValue;
	    exit;
	  endif;
    enddo;

    //adding a new variable if in case it hasn't been set alerady
    i = 0;
    while i <= maxocc(TASKS.TASK_VARIABLES) do 
      i = i + 1;
	  if length(strip(TASK_VARNAME(i))) = 0 then
	    TASK_VARNAME(i) = strip(varName);
	    TASK_VARVAL(i) = strip(varValue);
	    break;
	  endif;
    enddo;
  end;

  //Getting the variable value using varibale name for the currently loaded task
  function string getTaskVar(string varName)
    do i = 1 while i <= maxocc(TASKS.TASK_VARIABLES)
      if length(strip(TASK_VARNAME(i))) = 0 then
	    break;
	  endif;
      if toupper(strip(varName)) = toupper(strip(TASK_VARNAME(i))) then
	    getTaskVar = strip(TASK_VARVAL(i));
	    break;
  	  endif;
    enddo;
  end;



function endmess();
  { Returns true if response is REVIEW }
  endmess = ({addmode and}
             accept("Fin du questionnaire",
                     "Vérifier du questionnaire",
                     "Nouvelle quête./Questionnaire après") 
                     <> 2);
end;
{FR}
function alphachk(alpha(26) alphamask);
{  russian_convert();}
  { first remove all blanks, and duplicate question marks }
  alphanew = "";
 numeric  qmark = 0;
 numeric  lx = 1  l  a ;
  do l = 1 while l <= length(strip(alphavar))
    if alphavar[l:1] <> " " and (alphavar[l:1] <> "?" or not qmark) then
      alphanew[lx:1] = alphavar[l:1];
      lx = lx + 1;
      if alphavar[l:1] = "?" then
        qmark = 1;
      endif;
    endif;
  enddo;
  { aok = 0 - string is bad, aok = 1 - string is good }
numeric   totlen = length(strip(alphamask));
 numeric  aok = 0;           { assume string is bad - for empty string }
 numeric alphsize = length(strip(alphanew));
  if alphsize then   { not empty string }
    { check for "?" as only character }
    aok = (alphanew[1:1] = "?" and alphsize = 1);
    if !aok then     { if not a single "?", check string }
      aok = 1;       { now assume string is good until we know otherwise }
      l = 1;         { l is position in string of acceptable values }
      a = 1;         { a is position in input string }
      { loop while the string is still good and there are more letters }
      while aok and a <= alphsize do
        aok = pos(alphanew[a:1],alphamask[l:totlen-l+1]);
        if aok then     { letter is acceptable }
          l = l + aok;  { increment l to position after letter in string of acceptable values }
          a = a + 1     { increment a to next letter in input string }
        endif;
      enddo;
    endif;
  endif;
  alphachk = (!aok);    { alphachk = 0 - if string is good, = 1 - if string is bad }
  { now expand variables }
  if aok then
    do l = 1 while l <= length(strip(alphamask))
      if pos(alphamask[l:1],alphanew) then
        alphavar[l:1] = alphamask[l:1]
      elseif pos("?",alphanew) then
        alphavar[l:1] = "?"
      else
        alphavar[l:1] = " "
      endif;
    enddo;
  endif;
end;

{ function to clear codes and labels for household members }
function clean_labels();
	do i = 1 while i <= 30 by 1
	  codes(i)  = notappl;
	  labels(i) = "";
	enddo;
end;

function onStop();
    savepartial();
    stop(-1);
end;

function listenom()  ;
    clear_labels(); 
     i=1;
      setfile( FichSaPart, concat("C:\RDC123\Data\H",edit("999",M181), edit("999",M18INT), ".dat")) ;  
	     if Filesize( FichSaPart ) > 0 then
		     while FileRead( FichSaPart, strpart ) do
		          if strpart[11:3] = "0HL" and tonumber(strpart[4:2]) = M182 and tonumber( strpart[70:2]) >= 7 then  

					 	codes(i) = tonumber(strpart[14:2]);
		           		labels(i)= strip (strpart[16:40]);
     				      i=i+1;	                      
  
		          endif ;
		      enddo;
          endif ;
         close( FichSaPart );		    		 	   			
end;

{PROC C1A

postproc
libelle = getlabel(C1A_VS1,C1A); 

C1A_NOM = libelle;
}
PROC EPMU1M18_FF



preproc
  //Initializing global variables
  SetGlobalVariables();
  tempDir = projectDir + "\Temp";
  utilsDir = projectDir + "\Utils";
  
  setfont(All,"Cambria",30);
  
   setvaluesets("_FRA");  //to set valuesets in French


  //reading the task
  TASK_ID = trimQuotes(readEnviValue("taskId"));
  loadcase(TASKS, TASK_ID);

  //if task is water quality questionnaire task, loading parent household task
  if strip(TASK_TEMPLATENAME) <> "hh_int" & length(strip(TASK_PARENTID)) > 0 then
    TASK_ID = TASK_PARENTID;
    loadcase(TASKS, TASK_ID);
  endif;



  hhnum  = 0;       { last household number used }
 


  cln=tonumber(sysparm()[1:3]);
  hhn=tonumber(sysparm()[4:2]);
  xintnum  = tonumber( sysparm()[9:3] );
  xsupnum  = tonumber( sysparm()[12:3] );


  alphalst = "ABCDEFGHIJKLMNOPQRSTUVWXYZÃÇÅÄÁÆÈÊËÌÍÎÏÐÑÒÓÔÕÖØÙÚÛÝÞßáãäåæíÉìÂ";
 

  { settings for CAPI }

  set attributes (EPMU1M18) assisted on;
  set attributes (EPMU1M18) assisted off (variable (title));

  { set up minimal user bar }
  userbase();
  userbar( show );


postproc
  { update file with households assigned to interviewers }
   //if !xmodcent then
   //  updthhassgn();
   //endif;
  if !xmodcent then      { central office desn't have to exit after reviewing one HH }
    stop(-1);
  endif;
  



PROC M18


preproc
if demode() = add then addmode = 1 endif;
if demode() = modify then addmode = 2 endif;
if demode() = verify then addmode = 3 endif;

  
  if ispartial() then
    advance to getsymbol(savepartial);
  endif;


postproc
endlevel 
PROC M181

preproc
  if special(visualvalue($)) then
    $ = cln;
  endif;

postproc
  YCLUSTER = $;
  if loadcase( CLUSTERS, YCLUSTER ) then
    M187 = YURBRUR;
    M188 = YREGION;
  endif;


PROC M182

preproc
  if hhn <> 0 & (special(visualvalue($)) | visualvalue($) = hhn) then
    $ = hhn;
  endif;

postproc
  set attributes(M18NAME) native;
  if addmode then
    M18NAME = getTaskVar("hhead");
    M18ADDR = getTaskVar("address");
  else
    if length(strip(M18NAME)) then 
      set attributes (M18NAME) protect;
      set attributes (M18ADDR) protect;
    else 
      M18NAME = getTaskVar("hhead");
      M18ADDR = getTaskVar("address");
    endif;
  endif;

PROC M18INT
preproc
  if addmode | special(visualvalue($)) then
    $ = xintnum;
    M18INT = xintnum;
    M18HINT = xsupnum;
  endif;
  
PROC M183


preproc
  if addmode | special(visualvalue($)) then
    $ = 0;
    M18INT = xintnum ;
    M18HINT = xintnum;
  endif;
  
PROC M18NAME
preproc
  if !addmode then
    exit;
  endif;
PROC M18ADDR

preproc
  if !addmode then
    exit;
  endif;

  
PROC M186J

//if addmode and not M186J in 1:31 then //and M186J!="") and  (M186M!="") and  (M186A!="")) then
//  M186J = sysdate( "DD" );
 // M186M = sysdate( "MM" );
 // M186A = sysdate( "YYYY" );
//endif;

preproc
if demode() = add then 
	if special(visualvalue($)) then
	    x = sysdate();
	    if M186J = notappl then M186J = sysdate( "DD" );endif;
	    if M186M = notappl then M186M = sysdate( "MM" );endif;
	    if M186A = notappl then M186A = sysdate( "YYYY" );endif;
	endif;
endif;

postproc
numeric xdate;
xdate = (((visualvalue(M186A)*100)+visualvalue(M186M))*100)+ M186J;
if xdate > sysdate("YYYYMMDD") then 
errmsg("la date saisie est supérieure à la date du jour ,veuillez régler la date de la tablette");
stop(1) ;
endif;
PROC M187


preproc
  if addmode | special(visualvalue($)) then
    M187 = 1;
  endif;
  
PROC M188

preproc

M188 = 10 ;
PROC M189H

preproc
if demode() = add then
  if special(visualvalue($)) then
    x = systime();
    if M189H = notappl then M189H = int(x / 10000);endif;
    if M189M = notappl then M189M = int(x / 100) % 100;endif;
  endif;
endif;

postproc
last();
PROC M1811

preproc

//execsystem("explorer shell:appsfolder\microsoft.windowscamera_8wekyb3d8bbwe!app");

postproc

  if $ <> 1 then
    skip to M1817
  endif;
  
if not invalueset(M1811, M1811_VS1) then
	errmsg("Valeur Incorrecte, Modalité inconnue");
  reenter;
endif;

PROC C01A

postproc

if C01A = 2 then
	errmsg(" Etes-vous sûr qu'aucun de ces chocs n'a affecté le ménage ? ")
      select("Non, aucun Choc", continue, " Revenir ", $);
      skip to M1817 ;
endif;
PROC C02A

postproc

	if $>5 then 
		errmsg("Valeur Incorrecte, veillez corriger");
		reenter;
	endif;
PROC C1_ID

preproc 
C1_ID = curocc();
noinput
PROC C01

postproc

libelle = getlabel(C01_VS1,C01);
C1A_NOM = libelle;

if not invalueset(C01, C01_VS1) and not special($) then
	errmsg("Valeur Incorrecte, Modalité inconnue");
	reenter;
endif;

PROC C02

postproc

if not invalueset(C02, C02_VS1) and not special($) then
	errmsg("Valeur Incorrecte, Modalité inconnue");
	reenter;
endif;


PROC C03

postproc

if not invalueset(C03, C03_VS1) and not special($)  then
	errmsg("Valeur Incorrecte, Modalité inconnue");
	reenter;
endif;
PROC C04

preproc
if C03=2018 then
	fcmois();
	setvalueset(@getsymbol(),codes,labels);
	setcapturetype($,3);
endif;

postproc

if not invalueset(C04, C04_VS1) and not special($)  then
	errmsg("Valeur Incorrecte, Modalité inconnue");
	reenter;
endif;

lib_mois = getlabel(C04_VS1,C04); 

savepartial();

PROC C05

preproc 
	if C01 = 1 				then setvalueset(C05, C05_VS1); endif;
	if C01 = 2			 	then setvalueset(C05, C05_VS2); endif;
	if C01 = 3 				then setvalueset(C05, C05_VS3); endif;
	if C01 = 4 				then setvalueset(C05, C05_VS4); endif;
	if C01 = 5 				then setvalueset(C05, C05_VS2); endif;

postproc

	if C01 = 1 and not invalueset(C05, C05_VS1) then
		errmsg("Valeur Incorrecte, Modalité inconnue");
		reenter;
	endif;
	
	if C01 = 2 and not invalueset(C05, C05_VS2) then
		errmsg("Valeur Incorrecte, Modalité inconnue");
		reenter;
	endif;
	
	if C01 = 5 and not invalueset(C05, C05_VS2) then
		errmsg("Valeur Incorrecte, Modalité inconnue");
		reenter;
	endif;
	
	if C01 = 3 and not invalueset(C05, C05_VS3) then
		errmsg("Valeur Incorrecte, Modalité inconnue");
		reenter;
	endif;
	
	if C01 = 4 and not invalueset(C05, C05_VS4) then
		errmsg("Valeur Incorrecte, Modalité inconnue");
		reenter;
	endif;
	
PROC C06
alphavar = $;
numeric long longx;
  if alphachk("ABCDEFGHIJKLMNX") then
    errmsg(9998);
    reenter
  else
    $ = alphavar;
  endif;

if pos("X",$) then
	errmsg(" Veillez précisez le bien svp");
  		editnote();
    if length (strip(editnote()))< 2 then
  		errmsg("bien affecté non valide, Veuillez entrer plus de précision");
    	reenter;
	endif;
endif;


	
PROC C07
preproc
numeric message;

killfocus

if demode() = modify then
	if $=1 or $=2 then
		message = errmsg("Etes-vous sûr de vouloir corriger cette valeur?")
			select("Oui, je veux modifier",continue,"Non, Je ne corrige pas",continue);
			if message = 1 then
				editnote();
				if length (strip(editnote()))< 2 then
	  				errmsg("Veuillez entrer plus de précision");
	    		reenter;
				endif;
			endif;
			
			if message = 2 then
				if C07 = 2 then
					if (demode() = add) then
						C08A 	=notappl;
						C08 	="";
						C09		=notappl;
						C10		=notappl;
						C11A	=notappl; 
						C11		=""; 
						C12		=notappl;
						C13		=notappl;
						skip to C14;
					endif;
				 skip to C14;
				endif;
			endif;
	endif;	
endif;

postproc

if not invalueset(C07, C07_VS1) and not special($) then
	errmsg("Valeur Incorrecte, Modalité inconnue");
	reenter;
endif;


	
if C07 = 2 then
	if (demode() = add) then
		C08A 	=notappl;
		C08 	="";
		C09		=notappl;
		C10		=notappl;
		C11A	=notappl; 
		C11		=""; 
		C12		=notappl;
		C13		=notappl;
		skip to C14;
	endif;
 skip to C14;
endif;

PROC C08A
preproc
  clear_labels();
    i=1;


Onfocus
//listenom() ;
//--------------------------------------------------------------------------------------------------------------------------
setfile( FichSaPart, concat("C:\RDC123\Data\H",edit("999",M181), edit("999",M18INT), ".dat")) ;  
	     if Filesize( FichSaPart ) > 0 then
		     while FileRead( FichSaPart, strpart ) do
		          if strpart[11:3] = "0HL" and tonumber(strpart[4:2]) = M182 and tonumber( strpart[70:2]) >= 7 then  
						cl=0 ;
						for j in MODCH1000 do		 	      
							if C08A(j) = tonumber(strpart[14:2]) then
								cl=1 ;
			                endif;
			           	enddo;
	                    
	                 	if cl=0 and special(C08A(j)) then
					 		codes(i) = tonumber(strpart[14:2]);
		           			labels(i)= strip (strpart[16:40]);
     				      i=i+1;
     				    endif;	                      
		          endif;
		      enddo;
          endif;
         close(FichSaPart);		    		 	   			
//---------------------------------------------------------

		if i = 1 then
		  errmsg("Aucun Membre de Ménage");
		  Reenter $;
		endif;
				
setvalueset(@getsymbol(),codes,labels);
setcapturetype($,3);


postproc

do varying j = 1 until  codes(j) = notappl  or j > i
  if codes(j) = $ then
    C08 = labels(j);
  endif;
  
enddo;


if not invalueset(C08A, C08A_VS1) and not special($)  then
	errmsg("Valeur Incorrecte, Modalité inconnue");
	reenter;
endif;
PROC C09
postproc
if not invalueset(C09, C09_VS1) and not special($)  then
	errmsg("Valeur Incorrecte, Modalité inconnue");
	reenter;
endif;
PROC C10
postproc

if not invalueset(C10, C10_VS1) and not special($)  then
	errmsg("Valeur Incorrecte, Modalité inconnue");
	reenter;
endif;

	if !pos("A",C06) and (C10 = 3 or C10 = 5) then
		errmsg(" Modalités Incompatibles! Veuillez corriger")
			select("Corriger les biens affectés",C06," Corriger la raison principale ",$);
	endif;
	
	if !pos("F",C06) and C10 = 2 then
		errmsg(" Modalités Incompatibles! Veuillez corriger")
			select("Corriger les biens affectés",C06," Corriger la raison principale ",$);
	endif;

	if !pos("C",C06) and C10 = 1 then
		errmsg(" Modalités Incompatibles! Veuillez corriger")
			select("Corriger les biens affectés",C06," Corriger la raison principale ",$);
	endif;
savepartial();

PROC C10A

postproc

if not invalueset(C10A, C10A_VS1) and not special($)  then
	errmsg("Valeur Incorrecte, Modalité inconnue");
	reenter;
endif;

if $=2 then
	C11A=notappl;
	C11= "";
	C12=notappl;
	C13=notappl;
	skip to C14;
endif;
PROC C11A

preproc

 if i=2 then  skip to C14 ; endif ;  // s'il n'y qu'une seule personne dans le ménage
  clear_labels();
    i=1;

Onfocus
//listenom() ;
//--------------------------------------------------------------------------------------------------------------------------
setfile( FichSaPart, concat("C:\RDC123\Data\H",edit("999",M181), edit("999",M18INT), ".dat")) ;  
	     if Filesize( FichSaPart ) > 0 then
		     while FileRead( FichSaPart, strpart ) do
		          if strpart[11:3] = "0HL" and tonumber(strpart[4:2]) = M182 and tonumber( strpart[70:2]) >= 7 then  
						cl=0 ;
						for j in MODCH1000 do		 	      
							if C08A(j) = tonumber(strpart[14:2]) then
								cl=1 ;
			                endif;
			           	enddo;
	                    
	                 	if cl=0 and special(C11A(j)) then
					 		codes(i) = tonumber(strpart[14:2]);
		           			labels(i)= strip (strpart[16:40]);
     				      i=i+1;
     				    endif;	                      
		          endif;
		      enddo;
          endif;
         close(FichSaPart);		    		 	   			
//---------------------------------------------------------
		if i = 1 then
		  errmsg("Aucun Membre de Ménage");
		  Reenter $;
		endif;
				
setvalueset(@getsymbol(),codes,labels);
setcapturetype($,3);

postproc

  if C08A = C11A then
    errmsg(" Même personne "); reenter ;
  endif;

do varying j = 1 until  codes(j) = notappl  or j > i
  if codes(j) = $ then
    C11 = labels(j);
  endif;
enddo;
PROC C12
postproc

if not invalueset(C12, C12_VS1) and not special($)  then
	errmsg("Valeur Incorrecte, Modalité inconnue");
	reenter;
endif;

if $ > C09 then
	errmsg(" Valeur incorrecte, le nombre de jours de travail perdus par %s doit être inférieur à celui de %s",C11,C08);
	reenter;
endif
PROC C13

postproc
{----------------------------------------------------------------------}
if not invalueset(C13, C13_VS1) and not special($)  then
	errmsg("Valeur Incorrecte, Modalité inconnue");
	reenter;
endif;
{----- -Contrôle sur compatibilité des modalités---------------------------------------------------------}
	if !pos("A",C06) and (C13 = 3 or C13 = 5) then
		errmsg(" Modalités Incompatibles! Veuillez corriger")
			select("Corriger les biens affectés",C06," Corriger la raison principale ",$);
	endif;
	
	if !pos("F",C06) and C13 = 2 then
		errmsg(" Modalités Incompatibles! Veuillez corriger")
			select("Corriger les biens affectés",C06," Corriger la raison principale ",$);
	endif;

	if !pos("C",C06) and C13 = 1 then
		errmsg(" Modalités Incompatibles! Veuillez corriger")
			select("Corriger les biens affectés",C06," Corriger la raison principale ",$);
	endif;
{----------------------------------------------------------------------}

savepartial();

	if demode() = add or demode() = modify then
		if pos("A",C06)=0 then
			C14		=notappl;
			C15A	=notappl;
			C15		="";
			C16		=notappl;
			C17		=notappl;
			skip to C18;
		endif;
	endif;
PROC C14

preproc
	
	if pos("A",C06) <> 0 then
		$=2;
	endif;


Postproc

if not invalueset(C14, C14_VS1) and not special($)  then
	errmsg("Valeur Incorrecte, Modalité inconnue");
	reenter;
endif;

if C14 = 2 and curocc()=C1_ID then 

	if demode() = add or demode() = modify then
		C15 	="";
		C15A 	=notappl;
		C16		=notappl;
		C17		=notappl;
		skip to C18A;
	endif;
   
   skip to C18;
endif;
PROC C15A
Onfocus
listenom() ;
		if i = 1 then
		  errmsg("Aucun Membre de Ménage");
		  Reenter $;
		endif;
				
setvalueset(@getsymbol(),codes,labels);
setcapturetype($,3);



postproc

do varying j = 1 until  codes(j) = notappl  or j > i
  if codes(j) = $ then
    C15 = labels(j);
  endif;
enddo;
PROC C16

postproc

if not invalueset(C16, C16_VS1) and not special($)  then
	errmsg("Valeur Incorrecte, Modalité inconnue");
	reenter;
endif;

if demode() = modify or demode()= add then

	if $ < 1000 then
		errmsg(" Valeur Incorrecte! Etes - vous sûr que la dépense n'a coûté que %d FC",$)
			select(" Corrigez la valeur",$,"Oui, la valeur est correcte",continue);
			errmsg("Justifier");
				editnote();
			if length(strip(editnote()))<15 then
				errmsg(" Veuillez entrer plus de précision ou corriger la valeur");
				reenter;
			endif;
	endif;
	
	if $%50<>0  then
		j = errmsg(" Valeur Incorrecte! Veuillez entrer le montant effectivement payé en FC")
			select(" Corrigez la valeur",$,"Oui la valeur est correcte",continue);
			
		if j=2 then
			errmsg("Justifier");
			editnote();
				
			if length(strip(editnote()))<15 then
				errmsg(" Veuillez entrer plus de précision");
				reenter;
			endif;			
		endif;
			
	endif;
endif;


if $ > 500000 then 
		errmsg(" Etes - vous sûr que la dépense a coûté %d FC",$)
		select(" Corrigez la valeur",$,"Oui, la valeur est correcte",continue);
endif ;



if $ < 5000 then 
		errmsg(" Etes - vous sûr que la dépense a coûté %d FC",$)
		select(" Corrigez la valeur",$,"Oui, la valeur est correcte",continue);
endif ;


PROC C17

postproc

if not invalueset(C17, C17_VS1) and not special($)  then
	errmsg("Valeur Incorrecte, Modalité inconnue");
	reenter;
endif;




savepartial();
PROC C18A
if not invalueset(C18A, C18A_VS1) and not special($) then
	errmsg("Valeur Incorrecte, Modalité inconnue");
	reenter;
endif;
PROC C18

postproc

numeric msg;

	if not invalueset(C18, C18_VS1)  and not special($)  then
		errmsg("Valeur Incorrecte, Modalité inconnue");
		reenter;
	endif;
	
	if C18 = 2 then
		C19=""; 
	   skip to C20;
	endif;
PROC C19

postproc

if pos("A",C19)=1 and length(strip(C19))> 1 THEN
   errmsg("La modalité 'Tout Perdu' ne peut être choisie avec les autres")
   	select("Cliquez Ici pour Corriger",$);
endif;

if pos("A",C19)=1 and length(strip(C19))= 1 THEN
   C19A="";
   C19B="";
   C19C="";
   skip to C20;
endif;

//Contrôle des valeurs saisies

alphavar = $;
numeric long longx;
  if alphachk("ABCDEFGHIJKLMNX") then
    errmsg(9998);
    reenter
  else
    $ = alphavar;
  endif;

if pos("X",$) then
	errmsg(" Veillez précisez le bien svp");
  		editnote();
    if length (strip(editnote()))< 5 then
  		errmsg("bien affecté non valide");
    	reenter;
	endif;
endif;
PROC C19A

preproc

if pos("B",C19) = 0 then
	C19A="";
	skip to C19B;
endif;

if pos("A",C19) = 1 then
	C19A="";
	skip to C19B;
endif;

postproc

alphavar = $;
numeric long longx;
  if alphachk("ABCDEFGHI") then
    errmsg(9998);
    reenter
  else
    $ = alphavar;
  endif;
PROC C19B

preproc

if pos("C",C19) = 0 then
	C19B="";
	skip to C19C;
endif;

if pos("A",C19) = 1 then
	C19B="";
	skip to C19C;
endif;

postproc

alphavar = $;
numeric long longx;
  if alphachk("ABCDEFGH") then
    errmsg(9998);
    reenter
  else
    $ = alphavar;
  endif;
PROC C19C

preproc

if pos("G",C19) = 0 then
	C19C="";
	skip to C20;
endif;

if pos("A",C19) = 1 then
	C19C="";
	skip to C20;
endif;

postproc
alphavar = $;
numeric long longx;
  if alphachk("ABCDEFGHIJKLMNOPQRSTUVWX") then
    errmsg(9998);
    reenter
  else
    $ = alphavar;
  endif;
PROC C20

postproc 

if C20 in 2,3 then 
	C20A=notappl;
	C20B=notappl;
   skip to C21;
endif;
PROC C21

preproc

if pos("A",C06)> 0 or pos("B",C06)> 0 then
	noinput;
endif;

postproc

if pos("I",C06)> 0 and C21=notappl then
	errmsg("Vous  aviez déclaré que les prix ont été &ffecté")
		select("Veuillez Corriger la valeur",$);
		reenter;
endif;


if C21 = 2 then 
	C21A=notappl;
	skip to C21B 
endif

PROC C21A

postproc

if not invalueset(C21A, C21A_VS1) and not special($) then
	errmsg("Valeur Incorrecte, Modalité inconnue");
	reenter;
endif;
PROC C21B
postproc

if not invalueset(C21B, C21B_VS1) and not special($)  then
	errmsg("Valeur Incorrecte, Modalité inconnue");
	reenter;
endif;

savepartial();
PROC C22

postproc

if not invalueset(C22, C22_VS1) and not special($)  then
	errmsg("Valeur Incorrecte, Modalité inconnue");
	reenter;
endif;
PROC C22A
postproc

if not invalueset(C22A, C22A_VS1) and not special($)  then
	errmsg("Valeur Incorrecte, Modalité inconnue");
	reenter;
endif;

	if $ = C22 then
		errmsg("La 2ème raison doit être différente de la raison principale")
			select("Corriger la raison principale",C22,"Corriger la deuxième Raison",$);
	endif;
	
PROC C23

postproc
if not invalueset(C23, C23_VS1) and not special($)  then
	errmsg("Valeur Incorrecte, Modalité inconnue");
	reenter;
endif;

if $ = 2 then 
	C24=notappl;
	C25=notappl;
   skip to C26;
endif;
PROC C24

postproc
if not invalueset(C24, C24_VS1) and not special($) then
	errmsg("Valeur Incorrecte, Modalité inconnue");
	reenter;
endif;
PROC C25

postproc
if not invalueset(C25, C25_VS1) and not special($) then
	errmsg("Valeur Incorrecte, Modalité inconnue");
	reenter;
endif;
PROC C26
postproc

if $ = 2 and curocc(MODCH1000) < C02A then
	 AUTRE = 1;
	 C27="";
	 C28=""; 
	skip to next;
endif;

if $ = 2 and curocc(MODCH1000) = C02A then
	 AUTRE = 1;
	 C27="";
	 C28=""; 
   skip to AUTRE;
endif;

if not invalueset(C26, C26_VS1) and not special($) then
	errmsg("Valeur Incorrecte, Modalité inconnue");
	reenter;
endif;
PROC C27


postproc 

alphavar = $;
  if alphachk("ABC") then
    errmsg(9998);
    reenter
  else
    $ = alphavar;
  endif;
  
savepartial();
PROC C28

postproc

alphavar = $;
  if alphachk("ABCDEX") then
    errmsg(9998);
    reenter
  else
    $ = alphavar;
  endif;

if pos("X",$) then
 editnote();
    if length (strip(editnote()))< 2 then
  		errmsg("Assistance non valide");
    	reenter;
	endif;
endif;

if curocc(MODCH1000) < C02A then
	 AUTRE = 1;
	skip to next;
endif;

if curocc(MODCH1000) = C02A then
   skip to AUTRE;
endif;
PROC AUTRE

preproc
    //AUTRE = 1; 
 if curocc() <> C02A then   
    noinput ;
 {else
     AUTRECHOC = 2;
     skip to next; }
endif;
   
   
onfocus
	if AUTRE = 1 then
		noinput;
	endif;


postproc
if AUTRE = 1 and curocc() = C02A   then C02A = C02A +1 ; endif ;

savepartial();
PROC REPONDANT

onfocus
//listenom() ;

//==========================================================================================================================
clear_labels(); 
     i=1;
      setfile( FichSaPart, concat("C:\RDC123\Data\H",edit("999",M181), edit("999",M18INT), ".dat")) ;  
	     if Filesize( FichSaPart ) > 0 then
		     while FileRead( FichSaPart, strpart ) do
		          if strpart[11:3] = "0HL" and tonumber(strpart[4:2]) = M182 and tonumber( strpart[70:2]) >= 15 then  
					 	codes(i) = tonumber(strpart[14:2]);
		           		labels(i)= strip (strpart[16:40]);
     				      i=i+1;	                      
		          endif ;
		      enddo;
          endif ;
         close( FichSaPart );	
//==========================================================================================================================
		if i = 1 then
		  errmsg("Aucun Membre de Ménage");
		  //Reenter $;
		endif;
				
setvalueset(@getsymbol(),codes,labels);
setcapturetype($,3);

postproc

do varying j = 1 until  codes(j) = notappl  or j > i
	
  if codes(j) = $ then
	REPONDANT_B = labels(j);
  endif;
enddo;
PROC REPONDANT_B

preproc

if $<>"" then
	noinput;
endif;
PROC M1817

preproc

numeric xx;
xx=C02A;
	
	if M1811 <> 1 then $=4; noinput; endif;
	if xx>=1 and length(C28(xx))>=1  then M1817=1; noinput; endif;
	if M1817=1 then noinput; endif ;
	
	move to M18FIN;
	//stop(-1);
PROC M1810H

preproc
if demode() = add then
  if special(visualvalue($)) then
    x = systime();
    if M1810H = notappl then M1810H = int(x / 10000);endif;
    if M1810M = notappl then M1810M = int(x / 100) % 100;endif;
  endif;
endif;
PROC M18FIN


preproc
//=========================================================================================================================
      errmsg("VOUS VENEZ D'ACHEVER LE MODULE SUR LES CHOCS NATURELS");
//=========================================================================================================================
	$ = 3;
postproc

if $ = 1 then 
	errmsg(" Vous pouvez remonter ");
	reenter ;
endif;

if $ = 2 then editnote() endif;
$ = 3 ;

quitter();
