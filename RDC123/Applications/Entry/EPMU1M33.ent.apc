{Application 'EPMU1M33' logic file generated by CSPro}
PROC GLOBAL

set explicit;
{ Definitions of working variables }
array alpha(8) KishGrid(10);	   { Grid used for selection of child for child discipline module }
alpha(26) alphavar;				   { Alpha working variable used in checking alpha vars }
alpha(26) alphanew;                { Alpha working variable used in checking alpha vars }
alpha(62) alphalst;                { The alphabet }
array codes(50);                   { Array used for creating line numbers of household members sleeping under mosquito net}
array alpha(50) labels(50);        { Array used for creating names of household members sleeping under mosquito net} 
alpha(40) yname, ynamehh, tmpname; { List of names for questions }
alpha(900) strnotes;               { for editnote at the end of the interview }
alpha(40) worklabel;               { Alpha variable to get customize text for questions }

numeric   hhn,xintnum,xsupnum,xmodcent ;
 
numeric TOTPRIM,maxmain,MOMIN,MOMAX  maxdep;
numeric addmode i cln  hhnum x j ;
string strpart dmois xmois xunite libelle sixmoisavenir douzederniermois ;

 file FichSaPart ;


// sauvegarde des données 
Function sav()
	savepartial();
end;


// Quitter
Function quitter()
	savepartial();
	stop(1) ;
end;

{ User defined functions }

  function showCalc()
    execsystem("calc");
  end;

  { setup basic user bar }
  function userbase();
    userbar( clear );

    
    userbar(add text,"ECVM:MOD 33");
	userbar(set color,236,254,255);
	
    userbar( add button, "<",    do("PreviousField") );
    userbar( add button, ">",    do("NextField") );
    userbar( add button, ">>|",  do("AdvanceToEnd") );
    userbar( add button, "Note", do("EditNote") );
    userbar( add button, "Lang", do("ChangeLanguage") );
    userbar( add button, "Calc", showCalc );	
    
 	//userbar(add spacing,25);   
	userbar(add button,"Sauvegarde", sav());    
	//userbar(add spacing,25);
	userbar(add text," ");
	
	userbar(add button,"Quitter", quitter());    
	//userbar(add spacing,25);
	userbar(add text," ");
  end;
  
{ --------------------------------------------------------------------------- }
{ valid
  Checks that a variable has a valid value.
  A valid value is less than 96 and not a special value e.g notappl/missing
  Returns: 1 if valid, 0 if not valid                                        }

function valid(xvar);
  valid = (!special(xvar) and xvar < 96)
end;

{ -------------------------------------------------------------------------- }
{ NAtoZero
  Converts notappl (and 99 - for child labour module) values to zero while not changing other values.
  Returns: 0 if input variable is notappl, else returns it unchanged         }
function NAtoZero(xvar);
  if xvar = notappl or xvar=99 then
    xvar = 0
  endif;
  NAtoZero = xvar;
end;


{ clear_labels
Set value labels for certain questions where the response categories can change }
function clear_labels();
	do i = 1 while i <= 50
	  codes(i) = notappl;
	  labels(i) = "";
	enddo;
end;

//Setting a variable value for the currently loaded task
  function setTaskVar(string varName, string varValue)
    //first checking if the variable is already set
    for i in TASKS.TASK_VARIABLES do
      if toupper(strip(varName)) = toupper(strip(TASK_VARNAME(i))) then
	    TASK_VARVAL(i) = varValue;
	    exit;
	  endif;
    enddo;

    //adding a new variable if in case it hasn't been set alerady
    i = 0;
    while i <= maxocc(TASKS.TASK_VARIABLES) do 
      i = i + 1;
	  if length(strip(TASK_VARNAME(i))) = 0 then
	    TASK_VARNAME(i) = strip(varName);
	    TASK_VARVAL(i) = strip(varValue);
	    break;
	  endif;
    enddo;
  end;

  //Getting the variable value using varibale name for the currently loaded task
  function string getTaskVar(string varName)
    do i = 1 while i <= maxocc(TASKS.TASK_VARIABLES)
      if length(strip(TASK_VARNAME(i))) = 0 then
	    break;
	  endif;
      if toupper(strip(varName)) = toupper(strip(TASK_VARNAME(i))) then
	    getTaskVar = strip(TASK_VARVAL(i));
	    break;
  	  endif;
    enddo;
  end;



function endmess();
  { Returns true if response is REVIEW }
  endmess = ({addmode and}
             accept("Fin du questionnaire",
                     "Vérifier du questionnaire",
                     "Nouvelle quête./Questionnaire après") 
                     <> 2);
end;
{FR}
function alphachk(alpha(26) alphamask);
{  russian_convert();}
  { first remove all blanks, and duplicate question marks }
  alphanew = "";
 numeric  qmark = 0;
 numeric  lx = 1  l  a ;
  do l = 1 while l <= length(strip(alphavar))
    if alphavar[l:1] <> " " and (alphavar[l:1] <> "?" or not qmark) then
      alphanew[lx:1] = alphavar[l:1];
      lx = lx + 1;
      if alphavar[l:1] = "?" then
        qmark = 1;
      endif;
    endif;
  enddo;
  { aok = 0 - string is bad, aok = 1 - string is good }
numeric   totlen = length(strip(alphamask));
 numeric  aok = 0;           { assume string is bad - for empty string }
 numeric alphsize = length(strip(alphanew));
  if alphsize then   { not empty string }
    { check for "?" as only character }
    aok = (alphanew[1:1] = "?" and alphsize = 1);
    if !aok then     { if not a single "?", check string }
      aok = 1;       { now assume string is good until we know otherwise }
      l = 1;         { l is position in string of acceptable values }
      a = 1;         { a is position in input string }
      { loop while the string is still good and there are more letters }
      while aok and a <= alphsize do
        aok = pos(alphanew[a:1],alphamask[l:totlen-l+1]);
        if aok then     { letter is acceptable }
          l = l + aok;  { increment l to position after letter in string of acceptable values }
          a = a + 1     { increment a to next letter in input string }
        endif;
      enddo;
    endif;
  endif;
  alphachk = (!aok);    { alphachk = 0 - if string is good, = 1 - if string is bad }
  { now expand variables }
  if aok then
    do l = 1 while l <= length(strip(alphamask))
      if pos(alphamask[l:1],alphanew) then
        alphavar[l:1] = alphamask[l:1]
      elseif pos("?",alphanew) then
        alphavar[l:1] = "?"
      else
        alphavar[l:1] = " "
      endif;
    enddo;
  endif;
end;

{ function to clear codes and labels for household members }
function clean_labels();
	do i = 1 while i <= 30 by 1
	  codes(i)  = notappl;
	  labels(i) = "";
	enddo;
end;

//!!AI start
function onStop();
    savepartial();
    stop(-1);
end;
//!!AI end

PROC EPMU1M33_FF


preproc
  //Initializing global variables
  SetGlobalVariables();
  tempDir = projectDir + "\Temp";
  utilsDir = projectDir + "\Utils";
  
  setfont(All,"Cambria",30);
  
   setvaluesets("_FRA");  //to set valuesets in French


  //reading the task
  TASK_ID = trimQuotes(readEnviValue("taskId"));
  loadcase(TASKS, TASK_ID);

  //if task is water quality questionnaire task, loading parent household task
  if strip(TASK_TEMPLATENAME) <> "hh_int" & length(strip(TASK_PARENTID)) > 0 then
    TASK_ID = TASK_PARENTID;
    loadcase(TASKS, TASK_ID);
  endif;



  hhnum  = 0;       { last household number used }
 


  cln=tonumber(sysparm()[1:3]);
  hhn=tonumber(sysparm()[4:2]);
  xintnum  = tonumber( sysparm()[9:3] );
  xsupnum  = tonumber( sysparm()[12:3] );


  alphalst = "ABCDEFGHIJKLMNOPQRSTUVWXYZÃÇÅÄÁÆÈÊËÌÍÎÏÐÑÒÓÔÕÖØÙÚÛÝÞßáãäåæíÉìÂ";
 

  { settings for CAPI }

  set attributes (EPMU1M33) assisted on;
  set attributes (EPMU1M33) assisted off (variable (title));

  { set up minimal user bar }
  userbase();
  userbar( show );


postproc
  { update file with households assigned to interviewers }
   //if !xmodcent then
   //  updthhassgn();
   //endif;
  if !xmodcent then      { central office desn't have to exit after reviewing one HH }
    stop(-1);
  endif;

PROC M33

preproc
if demode() = add then addmode = 1 endif;
if demode() = modify then addmode = 2 endif;
if demode() = verify then addmode = 3 endif;

  
  if ispartial() then
    advance to getsymbol(savepartial);
  endif;


postproc
quitter() ;
PROC M331
preproc
  if special(visualvalue($)) then
    $ = cln;
  endif;

postproc

  YCLUSTER = $;
  if loadcase( CLUSTERS, YCLUSTER ) then
    M337 = YURBRUR;
    M338 = YREGION;
  endif;

PROC M332
preproc
  if hhn <> 0 & (special(visualvalue($)) | visualvalue($) = hhn) then
    $ = hhn;
  endif;

postproc
  set attributes(M33NAME) native;
  if addmode then
    M33NAME = getTaskVar("hhead");
    M33ADDR = getTaskVar("address");
  else
    if length(strip(M33NAME)) then 
      set attributes (M33NAME) protect;
      set attributes (M33ADDR) protect;
    else 
      M33NAME = getTaskVar("hhead");
      M33ADDR = getTaskVar("address");
    endif;
  endif;
PROC M33INT
preproc
  if addmode | special(visualvalue($)) then
    $ = xintnum;
    M33INT = xintnum;
    M33HINT = xsupnum;
  endif;
  
PROC M333
preproc
  if addmode | special(visualvalue($)) then
    $ = 0;
   M33INT = xintnum ;
   M33HINT = xintnum;
  endif;
  
PROC M337
preproc
  if addmode | special(visualvalue($)) then
    M337 = 1;
  endif;
PROC M338
preproc

M338 = 10 ;
PROC M33NAME
preproc
  if !addmode then
    exit;
  endif;
PROC M33ADDR
preproc
  if !addmode then
    exit;
  endif;
PROC M3311
postproc
  if $ <> 1 then
    skip to M3317
  endif;  
PROC M336J
preproc
if demode() = add then 
	if special(visualvalue($)) then
	    x = sysdate();
	    if M336J = notappl then M336J = sysdate( "DD" );endif;
	    if M336M = notappl then M336M = sysdate( "MM" );endif;
	    if M336A = notappl then M336A = sysdate( "YYYY" );endif;
	endif;
endif;

postproc
numeric xdate;
xdate = (((visualvalue(M336A)*100)+visualvalue(M336M))*100)+ M336J;
 if xdate > sysdate("YYYYMMDD") then 
errmsg("la date saisie est supérieure à la date du jour ,veuillez régler la date de la tablette");
stop(1) ;
endif;
PROC M339H
preproc
  if special(visualvalue($)) then
  if demode() = add then
    x = systime();
    if M339H = notappl then M339H = int(x / 10000);endif;
    if M339M = notappl then M339M = int(x / 100) % 100;endif;
  endif;
  endif;
PROC STRATEGIE_FORM
preproc

// 12 derniers mois
numeric xlastdate ;

 xlastdate = dateadd( ( ((M336A * 100) + M336M) * 100) + M336J  ,-13,"m"); 
string sldat =edit("99999999",xlastdate) ;

douzederniermois = concat( sldat[7:2] ," ", getlabel( M336M,tonumber(sldat[5:2])) , " ", sldat[1:4] ) ;


// 6 mois à venir
//numeric xlastdate ;

 //xlastdate = dateadd( ( ((M336A * 100) + M336M ) * 100) + M336J ,+6, "m"); 
//string sldat =edit("99999999",xlastdate) ;

//sixmoisavenir = concat( sldat[7:2] ," ", getlabel( M336M,tonumber(sldat[5:2])) , " ", sldat[1:4] ) ;


PROC SMQ01

if $ = 2 then
   skip to SMQ02
endif;
PROC SMQ02

if $ = 0 or $ = 2then
   skip to SMQ03
endif;
PROC SMQ03

if $ = 2 then
   skip to SMQ04A
endif;
PROC SMQ04A

if $ = 9 then
   skip to SMQ05A
endif;

If $ = 0 then
	skip to SMQ05A;
endif;
PROC SMQ04B

postproc

if $ = SMQ04A then
	errmsg("ENTRER UN AUTRE POSTE DE DEPENSE");
  Reenter;
  
Endif;

If $ = 0 then
	skip to SMQ05A;
endif;
PROC SMQ04C

postproc
if $ = SMQ04A or $ = SMQ04B then
	errmsg("ENTER UN AUTRE POSTE DE DEPENSE");
  Reenter;
Endif;
If $ = 0 then
	skip to SMQ05A;
endif;
PROC SMQ05A
if $ = 9 then
   skip to SMQ06
endif;
PROC SMQ05B

postproc
if $ = SMQ05A then
	errmsg("ENTER UN AUTRE POSTE DE DEPENSE");
  Reenter;
Endif;
if $ = 0 then
   skip to SMQ06
endif;
PROC SMQ05C

postproc
if $ = SMQ05A or $ = SMQ05B then
	errmsg("ENTER UN AUTRE POSTE DE DEPENSE");
  Reenter;
Endif;

if $ = 0 then
   skip to SMQ06
endif;
PROC SMQ05D

postproc
if $ = SMQ05A or $ = SMQ05B or $ = SMQ05C then
	errmsg("ENTER UN AUTRE POSTE DE DEPENSE");
  Reenter;
Endif;
if $ = 0 then
   skip to SMQ06
endif;
PROC SMQ05E

postproc
if $ = SMQ05A or $ = SMQ05B or $ = SMQ05C or $ = SMQ05D then
	errmsg("ENTER UN AUTRE POSTE DE DEPENSE");
  Reenter;
Endif;
PROC SMQ06

if SMQ04A = 9 AND SMQ06 <> 8 then
 errmsg(" vous avez declaré ne pas avoir des postes en baisse");
 endif; 

if SMQ06 = 7 then
   editnote()
endif;
sav();
PROC SMQ07A

If $ = 0 then
	skip to SMQ08A;
endif;

PROC SMQ07B

postproc
if $ = SMQ07A then
	errmsg("ENTER UN AUTRE PRODUIT DE DEPENSE");
  Reenter;
Endif;
if $ = 0 then
   skip to SMQ08A
endif;

PROC SMQ07C

postproc
if $ = SMQ07A or $ = SMQ07B then
	errmsg("ENTER UN AUTRE PRODUIT DE DEPENSE");
  Reenter;
Endif;
if $ = 0 then
   skip to SMQ08A
endif;
PROC SMQ07D

postproc
if $ = SMQ07A or $ = SMQ07B or $ = SMQ07C then
	errmsg("ENTER UN AUTRE PRODUIT DE DEPENSE");
  Reenter;
Endif;
if $ = 0 then
   skip to SMQ08A
endif;

PROC SMQ07E

postproc
if $ = SMQ07A or $ = SMQ07B or $ = SMQ07C or $ = SMQ07D then
	errmsg("ENTER UN AUTRE PRODUIT DE DEPENSE");
  Reenter;
Endif;
PROC SMQ08A

If $ = 0 then
	skip to SMQ09A;
endif;
PROC SMQ08B

postproc
if $ = SMQ08A then
	errmsg("ENTER UN AUTRE POSTE DE DEPENSE A AUGMENTER");
  Reenter;
Endif;
if $ = 0 then
   skip to SMQ09A
endif;
PROC SMQ08C

postproc
if $ = SMQ08A or $ = SMQ08B then
	errmsg("ENTER UN AUTRE POSTE DE DEPENSE A AUGMENTER");
  Reenter;
Endif;
if $ = 0 then
   skip to SMQ09A
endif;
PROC SMQ08D

postproc
if $ = SMQ08A or $ = SMQ08B or $ = SMQ08C then
	errmsg("ENTER UN AUTRE POSTE DE DEPENSE A AUGMENTER");
  Reenter;
Endif;
if $ = 0 then
   skip to SMQ09A
endif;
PROC SMQ08E

postproc
if $ = SMQ08A or $ = SMQ08B or $ = SMQ08C or $ = SMQ08D then
	errmsg("ENTER UN AUTRE POSTE DE DEPENSE A AUGMENTER");
  Reenter;
Endif;


PROC SMQ10
sav();
PROC SMQ15E
sav();
PROC REPONDANT

preproc
     clear_labels(); 
     i=1;
     
onfocus
     i=1;
      setfile( FichSaPart, concat("C:\RDC123\Data\H",edit("999",M331), edit("999",M33INT), ".dat")) ;  
	     if Filesize( FichSaPart ) > 0 then
		     while FileRead( FichSaPart, strpart ) do
		          if strpart[11:3] = "0HL" and tonumber(strpart[4:2]) = M332 and tonumber( strpart[70:2]) >= 18 then  
		                        codes(i) = tonumber(strpart[14:2]);
					           	labels(i)= strip (strpart[16:40]);
								 	i=i+1;				      	                      
	               endif;
		      enddo;
		      
          endif ;
         close( FichSaPart );
setvalueset(@getsymbol(),codes,labels);
setcapturetype(REPONDANT,3);
PROC M3310H
preproc
  if special(visualvalue($)) then
  if demode() = add then
    x = systime();
    if M3310H = notappl then M3310H = int(x / 10000);endif;
    if M3310M = notappl then M3310M = int(x / 100) % 100;endif;
  endif;
  endif;
PROC M33FIN

preproc
$ = 3;


postproc

if $ = 1 then 
	errmsg(" Vous pouvez remonter ");
	reenter SMQ01;
endif;

if $ = 2 then editnote() endif;

$ = 3 ;

quitter() ;
