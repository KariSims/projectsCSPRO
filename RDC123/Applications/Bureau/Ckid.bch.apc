{Application 'CKID' logic file generated by CSPro}
PROC GLOBAL
  
  string refDir, dataConcatDir, tasksDir, dataDir  LibTrouve  ;
  array summ(32, 5);  // Array qui détient des compteurs de compte pour le tableau récapitulatif
                     // Premières valeurs de dimetion: 1 - ménage;  suivi des modules
                     // Deuxième valeur de la dimension: 1 - total; 2 - comlete; 3 - incomplète; 4 - partielle; 5 - pas interviewé

  array foundHh(999); // gamme de ménages trouvés. Index - Numéro HH, valeur - nombre de ménages ayant le même nombre
  array duplHh(999, 999)// fait le suivi des ménages en double. Index - Numéro HH, Numéro de l'intervieweur, valeur - 0/1
  
// tableaux de barres de progression
  array pbHh(999, 2); // pour chaque ménage surveille les questionnaires individuels attendus / complétés 
                      // Première dimension - numéro de ménage, deuxième numérateur / dénominateur pour les particuliers
  array pbHhIdx(100); // indice pour le nombre de ménages
  numeric hhCount = 0 TROUVE ;
  numeric ModRempli = 0  Module = 0;

  numeric buffered; // drapeau pour l'exécution de la commande tamponnée 1 - tamponné, 2 - direct
  
  array intHh(9999, 999); // tableau des ménages assignés pour les intervieweurs indexés par le numéro de l'intervieweur
                          // l'élément '0' de la première dimension est pour les ménages non encore affectés
                          // l'élément '0' de la deuxième dimension est le nombre d'éléments dans la deuxième dimension
                          
  array hhIntAssign(9999); // tableau des numéros d'intervieweur indexés par les ménages assignés
  
  
  array string validInd(999,999); // définit des questionnaires individuels valides pour chaque ménage, intervieweur de ménage et numéro de ligne. Les valeurs sont des types de questionnaires et l'intervieweur de HH

   // Obtenir la valeur de la variable à l'aide du nom varibale pour la tâche actuellement chargée
  function string getTaskVar(string varName)
    numeric i;
    do i = 1 while i <= maxocc(TASKS.TASK_VARIABLES)
      if length(strip(TASK_VARNAME(i))) = 0 then
	    break;
	  endif;
      if toupper(strip(varName)) = toupper(strip(TASK_VARNAME(i))) then
	    getTaskVar = TASK_VARVAL(i);
	    break;
  	  endif;
    enddo;
  end;
  

  file filePart;
  function partialCs(qType, clust, intNum, hhNum, lineNum,string pcar)
    numeric found = 0, xlen;
    string fName = dataDir + "\" + pcar + edit("999", clust) + edit("999", intNum) + ".DAT.STS";   
    string findadd, findmod, strpart;

      findadd = "Pos=ADD." + edit("999", clust) + edit("99", hhNum) + edit("999", intNum);
      findmod = "Pos=MOD." + edit("999", clust) + edit("99", hhNum) + edit("999", intNum);
   
    xlen = length(strip(findadd));
    setfile(filePart, fName);
    open(filePart);
    while !found do
      if !FileRead( filePart, strpart ) then
        found = 3
      elseif pos( strip(findadd), strpart[1:xlen] ) then
        found = 1
      elseif pos( strip(findmod), strpart[1:xlen] ) then
        found = 2
      endif;
    enddo;
    close(filePart);
    if found in 1,2 then
      partialcs = found;
      TROUVE = found ;
    else
      partialcs = 0;
    endif;
  end;
  
  
		function partialH()  partialH  = partialCs(1, HH1, HINT, HH2, 0, "H");  end;

//file filePart;

  function EtatGrappe(string pcar,nGrappe, string xModule, i )
    numeric found = 0, xlen;
    string fname recherche  strpart ;

    
          fName = dataConcatDir + "\" + pcar + edit("999", nGrappe) + ".dat";   
          recherche = edit("999", nGrappe) ;
          setfile(filePart, fName);
		    open(filePart);
    
		    if Filesize( filePart ) > 0 then
		    	 while FileRead( filePart, strpart ) do
     
				     if pos( strip(recherche), strpart[1:3] ) then
				     
				       if strpart[11:3] = strip(xmodule) then    //  pour le module 
				          if tonumber(strpart[40:2]) in 1:7,96 then
				              found = 3 ;
				              summ(i,2) =  summ(i,2) + 1 ; // Complet
				              
				                if tonumber(strpart[40:2]) =1 then  LibTrouve = "Complet";    endif;
				                if tonumber(strpart[40:2]) =2 then  LibTrouve = "Terminé, pas de memebre à la maison";    endif;
				                if tonumber(strpart[40:2]) =3 then  LibTrouve = "Terminé, Ménage entier absent pour une longue période";    endif;
				                if tonumber(strpart[40:2]) =4 then  LibTrouve = "Terminé, Refus";    endif;				                
				                if tonumber(strpart[40:2]) =5 then  LibTrouve = "Terminé, logement vide";    endif;
				                if tonumber(strpart[40:2]) =6 then  LibTrouve = "Terminé, logement détruit";    endif;				                
				                if tonumber(strpart[40:2]) =7 then  LibTrouve = "Terminé, logement non retrouvé";    endif;
				                if tonumber(strpart[40:2]) =96 then LibTrouve = "Terminé, autre ";    endif;
				            else
				                LibTrouve = "En cours de saisie ";
				                summ(i,3) =  summ(i,3) + 1 ; // En partiel
				          endif;
				        endif; 
				       endif; 	        
		    
		       enddo ;
		     close(filePart); 
          endif;

  end; 
  		

  
  numeric errCount = 0;
  function writeError(errNumber, isError, string err)
    string w = "A";
    if isError then 
      w = "E"; 
    endif;
    addListItem("errlist", edit("99999", errNumber) + " " + w + " " + err);
    errCount = errCount + 1;
  end;
  
  
  

PROC EPMU1_FF
preproc
  setGlobalVariables();

  refDir = projectDir + "\Reference";      
  tempDir = projectDir + "\Temp";          
  utilsDir = projectDir + "\Utils";        
  dataConcatDir = projectDir + "\Receive"; 
  tasksDir = projectDir + "\Tasks";      
  
  setTempFolder(tempDir); // informe l'application conteneur de votre dossier temporaire
  
  buffered = 1; // exécution de la commande tamponnée par défaut
  
  //enableDebugMode(tempDir + "\debug.txt");
  
  numeric i, j, j1;

// Vider la mémoire
  if buffered then
    openBuffer(tempDir + "\buffer.tmp");
  endif;
  
 // effacer le document et lier le style (CSS)
  clearDocument();
  clearCssLinks();
  addCssLink(refDir + "\style1.css");
  
// étiquette de date
  setLabelCss("date", "Date: " + edit("99/99/9999", sysdate("DDMMYYYY")), "dateLabel");
  
// création de la liste des erreurs
  setList("errlist");
  
  //charger les informations de la grappe
  YCLUSTER = tonumber(sysparm()[1:5]);
  setDocumentTitle("Suivi de la grappe " + edit("999", YCLUSTER)); //!T
  setLabel("title", htmlHeader(1, "Grappe numéro : " + edit("999", YCLUSTER))); //!T

  string subtitle;
  if loadcase(CLUSTERS, YCLUSTER) then
    if length(strip(YPROVINN)) then subtitle = strip(YPROVINN) + " "; endif;
    if length(strip(YREGIONN)) then subtitle = subtitle + strip(YREGIONN) + " "; endif;
    if length(strip(YDISTRICTN)) then subtitle = subtitle + strip(YDISTRICTN) + " "; endif;
    if length(strip(YCOMUNEN)) then subtitle = subtitle + strip(YCOMUNEN) + " "; endif;
    if length(strip(YENUMERN)) then subtitle = subtitle + strip(YENUMERN) + " "; endif;
  else
    subtitle = "Grappe inconnue " //!T
  endif;
  setLabel("Subtitle", "Province / Commune / Commune Urbaine  /  Quartier  / Ilot  ");
  setLabel("Subtitle", htmlHeader(2, subtitle));

  //création du label de séparation
  setLabelCss("separator", " ", "separator");

  //Construction de la liste de tous les méanges de l'échantillon
  setTableCss("detailstab", "detailstable");
  setTableCss("detailstab1", "detailstable"); //table des menages non échantillonnés
   
  XCLUSTER = YCLUSTER;
  string hhDetails, tabName;

   // Étant donné que CSPro trie les données externes par ID, nous devons réaffecter l'ID des tâches pour correspondre aux numéros de ménage
   // sinon les ménages seront imprimés hors service
  close(TASKS);
// création d'une copie du fichier de tâches dans le dossier temporaire
  filedelete(tempDir + "\ckidTasks.dat");
  filedelete(tempDir + "\ckidTasks.dat.idx");
  filecopy(filename(TASKS), tempDir + "\ckidTasks.dat");
  
  setfile(TASKS, tempDir + "\ckidTasks.dat");
  open(TASKS);
  numeric hhNum;
  while loadcase(TASKS) do
    hhNum = tonumber(getTaskVar("hhnum"));
    if !special(hhNum) then
      delcase(TASKS, TASK_ID);
      TASK_ID = edit("99999", hhNum);
      writecase(TASKS, TASK_ID);
    endif;
  enddo;
  close(TASKS);
  
  open(TASKS);
 // charger les tâches d'assigantion
  numeric intNum, hhNumRoot;
  while loadcase(TASKS) do
    if strip(TASK_TEMPLATENAME) = "HHAssign" then //seulement pour les ménages assignés
      intNum = tonumber(getTaskVar("intNum"));
      hhNum = tonumber(getTaskVar("hhnum"));
      if !special(hhNum) then
        if TASK_STATUS = 1 then // ménages non assignés
          intNum = 0;
        endif;
        if !special(intNum) then
          i = inc(intHh(intNum, 0));
          intHh(intNum, i) = hhNum;
          hhIntAssign(hhNum) = intNum;
        endif;
      endif;
      
      hhNumRoot = tonumber(getTaskVar("hhnumroot"));
      tabName = "detailstab";
      if !special(hhNumRoot) then // le ménage ne fait pas partie de l'échantillon
        tabname = "detailstab1";
      endif;
      
      addTableRow(tabName);
      if special(hhNumRoot) then
        addTableCell("Ménage n° " + edit("99", hhNum), 1); //!T
      else
        addTableCell(makeText("Ménage n° %02D (Added for hosehold #%02D)", hhNum, hhNumRoot), 1); //!T
      endif;
      addTableRow(tabName);
      addTableCell("%hhdetails" + edit("99", hhNum) + "%", 0);
      
// Etablissons d'abord le tableau des détails du ménage à partir du fichier de sélection du ménage. sera remplacé par des données HH réelles s'il existe
      hhDetails = "Addresse : " + strip(getTaskVar("address")) + lbr; //!T
      hhDetails = hhDetails + "Chef de ménage : " + strip(getTaskVar("hhead")) + lbr; //!T

      if hhIntAssign(hhNum) > 0 then
        hhDetails = hhDetails + "Assigné à : " + edit("999", hhIntAssign(hhNum)) + lbr; //!T
      else
        hhDetails = hhDetails + "Non encore assigné " + lbr; //
      endif;
      hhDetails = hhDetails + "Resultat : Non visité" + lbr;
      setLabel("hhdetails" + edit("99", hhNum), hhDetails);
      
// création d'un tableau des détails du ménage, nécessaire dans le cas des ménages en double
      setTableCss("hhdetailstab" + edit("99", hhNum), "detailstable2");
      
     // ajoutant le ménage au tableau récapitulatif
      summ(1, 1) = summ(1, 1) + 1;
      
      hhCount = hhCount + 1;
      pbHhIdx(hhCount) = hhNum;
      
    endif;
  enddo;
  close(TASKS);
  
  
  
postproc

// remplissage de tables individuelles

//Module 01
   
  string indId;
  string hs;
  numeric isIndDupl;
  
//  NAB 
//  Module 01

EtatGrappe("8",HH1,"M01",2);
EtatGrappe("2",HH1,"M06",3);
EtatGrappe("E",HH1,"M07",4);
EtatGrappe("D",HH1,"M08",5);
EtatGrappe("Y",HH1,"M09",6);
EtatGrappe("4",HH1,"M10",7);
EtatGrappe("S",HH1,"M11",8);
EtatGrappe("M",HH1,"M12",9);
EtatGrappe("Q",HH1,"M13",10);
EtatGrappe("L",HH1,"M14",11);
EtatGrappe("X",HH1,"M15",12);
EtatGrappe("B",HH1,"M16",13);
EtatGrappe("Z",HH1,"M17",14);
EtatGrappe("R",HH1,"M18",15);
EtatGrappe("A",HH1,"M19",16);
EtatGrappe("C",HH1,"M20",17);
EtatGrappe("F",HH1,"M21",18);
EtatGrappe("G",HH1,"M22",19);
EtatGrappe("I",HH1,"M23",20);
EtatGrappe("J",HH1,"M24",21);
EtatGrappe("6",HH1,"M25",22);
EtatGrappe("K",HH1,"M26",23);
EtatGrappe("N",HH1,"M27",24);
EtatGrappe("O",HH1,"M28",25);
EtatGrappe("P",HH1,"M29",26);
EtatGrappe("U",HH1,"M30",27);
EtatGrappe("V",HH1,"M31",28);
EtatGrappe("W",HH1,"M32",29);
EtatGrappe("1",HH1,"M33",30);
EtatGrappe("3",HH1,"M34",31);
EtatGrappe("7",HH1,"M37",32);

  
  // ************************************************************************************************

  //constructing summary table
  setTableCss("sumtab", "summarytable");
  addTableRow("sumtab");
  addTableCell(" ", 1);
  addTableCell("Total", 1); 
  addTableCell("Complet", 1); 
  addTableCell("Partiel", 1); 
  addTableCell("En Modif", 1); 
  addTableCell("Non enqueté ", 1);

  
  do i = 1 while i <= 32 by 1
    //Calculer la dernière colonne de la table 
    summ(i, 1) = summ(1, 1) ;
    summ(i, 5) = summ(i, 1) - ( summ(i, 2) + summ(i, 3) +  summ(i, 4) ); //
    

    Module = Module + summ(i, 1) ;
    ModRempli =  ModRempli + summ(i, 2) ;

    addTableRow("sumtab");
    if i = 1 then  addTableCell("Ménage ", 1);
		    elseif i = 2	 then  addTableCell("Module 01 ", 1); 
		    elseif i = 3	 then  addTableCell("Module 06 ", 1); 
		    elseif i = 4	 then  addTableCell("Module 07 ", 1); 
		    elseif i = 5	 then  addTableCell("Module 08 ", 1); 
		    elseif i = 6	 then  addTableCell("Module 09 ", 1); 
		    elseif i = 7	 then  addTableCell("Module 10 ", 1); 
		    elseif i = 8	 then  addTableCell("Module 11 ", 1); 
		    elseif i = 9	 then  addTableCell("Module 12 ", 1); 
		    elseif i = 10	 then  addTableCell("Module 13 ", 1); 
		    elseif i = 11	 then  addTableCell("Module 14 ", 1); 
		    elseif i = 12	 then  addTableCell("Module 15 ", 1); 
		    elseif i = 13	 then  addTableCell("Module 16 ", 1); 
		    elseif i = 14	 then  addTableCell("Module 17 ", 1); 
		    elseif i = 15	 then  addTableCell("Module 18 ", 1); 
		    elseif i = 16	 then  addTableCell("Module 19 ", 1); 
		    elseif i = 17	 then  addTableCell("Module 20 ", 1); 
		    elseif i = 18	 then  addTableCell("Module 21 ", 1); 
		    elseif i = 19	 then  addTableCell("Module 22 ", 1); 
		    elseif i = 20	 then  addTableCell("Module 23 ", 1); 
		    elseif i = 21	 then  addTableCell("Module 24 ", 1); 
		    elseif i = 22	 then  addTableCell("Module 25 ", 1); 
		    elseif i = 23	 then  addTableCell("Module 26 ", 1); 
		    elseif i = 24	 then  addTableCell("Module 27 ", 1); 
		    elseif i = 25	 then  addTableCell("Module 28 ", 1); 
		    elseif i = 26	 then  addTableCell("Module 29 ", 1); 
		    elseif i = 27	 then  addTableCell("Module 30 ", 1); 
		    elseif i = 28	 then  addTableCell("Module 31 ", 1); 
		    elseif i = 29	 then  addTableCell("Module 32 ", 1); 
		    elseif i = 30	 then  addTableCell("Module 33 ", 1); 
		    elseif i = 31	 then  addTableCell("Module 34 ", 1); 
		    elseif i = 32	 then  addTableCell("Module 37 ", 1);

    endif;
    
    
    do j = 1 while j <= 5 by 1
      addTableCell(edit("ZZ9", summ(i, j)), 0);
    enddo;
  enddo;
  
  //calculating progress bar numerator (denominator is hhCount)
  numeric num = 0, hIdx;
  do i = 1 while i <= hhCount by 1
    hIdx = pbHhIdx(i);
    if pbHh(hIdx, 2) > 0 then
      num = num + pbHh(hIdx, 1) / pbHh(hIdx, 2);
    endif;
  enddo;
  
  //creating progress bar
  
  // progression par rapport au ménage
  // numeric pbVal = int(num * 100 / hhCount);
  
    // progression par rapport au module 
       numeric pbVal = int(ModRempli * 100 / Module);
 
  setProgressBar("pb1", pbVal);
  setProgressBarCss("pb1", "progressbar", "progressBarBack", "progressBarFront", "progressBarText");

  if int(num) < hhCount then  
    writeError(001,1,"Etat de la collecte : données incomplètes"); //
  endif;

  //creating interviewers table
  numeric intCount = tonumber(readEnviValue("teamNumbers.count"));
  numeric n, k;
  string intName, intList;
  if !special(intCount) then
    setTableCss("intervTab", "summarytable2");
    addTableRow("intervTab");
    
    addTableCell("Equipe ", 1); //!
    
    addTableCell("#", 1); //!T
    addTableCell("Ménages", 1); //!T

    do i = 0 while i <= intCount by 1 //note the zero base index
      if i < intCount then
        intNum = tonumber(readEnviValue(maketext("teamNumbers[%d]", i)));
        intName = maketext("%03D: %s", intNum, trimQuotes(readEnviValue(maketext("teamNames[%d]", i))));
      else
        intNum = 0;
        intName = "Non encore assigné"; //!T
      endif;
      
      addTableRow("intervTab");
      addTableCell(intName, 1);
      
      n = intHh(intNum, 0);
      
      addTableCell(maketext("%d", n), 1);
      
      //sorting households list (because CSPro sorts tasks by task ID...)
      do j = 1 while j < n by 1
        do j1 = j + 1 while j1 <= n by 1
          if intHh(intNum, j) > intHh(intNum, j1) then
           k = intHh(intNum, j);
           intHh(intNum, j) = intHh(intNum, j1);
           intHh(intNum, j1) = k;
          endif;
        enddo;
      enddo;
      
      //writing households list
      intList = "";
      do j = 1 while j <= n by 1
        intList = intList + maketext("%02D", intHh(intnum, j)) + ", ";
      enddo;
      addTableCell(intList, 0);
    enddo
  endif;
  
  //checking if supervisor verified at least one household schedule
  numeric hNeeded = 1; //expected minimum number of verified households
  numeric hCount = 0;  //count of actual verifired households found
  numeric sId = tonumber(sysparm()[6:5]);
  
  if !special(sId) then
    close(TASKS);
    setfile(TASKS, maketext("%s\T%05D%05D_Review.dat", tasksDir, YCLUSTER, sId));
    open(TASKS);
    while loadcase(TASKS) do
      if strip(TASK_TEMPLATENAME) = "hh_int" & TASK_STATUS = 21 then
        inc(hCount);
      endif;
    enddo;
    close(TASKS);
  
    if hCount < hNeeded then
     // writeError(50101, 1, maketext("Ménage vérifier par le chef d'équipe %d. Attendu pas moins que %d", hCount, hNeeded)); //!T
    endif;
  endif;

  //assembling the page and writing out the document
  addContent(div("", "logo") + projectName + "%date%");
  addContent("%title%%subtitle%%separator%");
  if errCount then //only writing out errors list if there were messages
    addContent("Erreurs : %errlist%%separator%"); //!T
  endif;
  
  addContent(div("Résumé : %pb1%%sumtab%", "sumDiv") + "%separator%"); //!T
  
  if !special(sId) then  
    addContent("Assignés :" + lbr + lbr +"%intervTab%%separator%"); //!T
  endif;
  
  
  addContent("Echantillon ménage : " + lbr + lbr + "%detailstab%%separator%"); //!T
  addContent("Ménages non echantillonnés :" + lbr + lbr + "%detailstab1%%separator%"); //!T
  
  addContent(projectName + "%date%");
  
  renderDocument(tempdir + "\ckid.html");
  
  //flushing the buffer and executing all recorded commands
  if buffered then
    closeBuffer();
  endif;
  
  //setting ENVI int variable 'ckidResult' with CKID result, value is number of errors
  execEnvi("int ckidResult = " + edit("999", errCount) + ";");
  
  //disableDebugMode();
  
PROC HH
preproc
  numeric i;

  numeric sampled = 0;
  do i = 1 while i <= hhCount by 1
    if HH2 = pbHhIdx(i) then
      sampled = 1;
      break;
    endif;
  enddo;
  if !sampled then
    addTableRow("detailstab1");
    
    addTableCell("Ménage n° " + edit("99", HH2), 1); //!T
    
    addTableRow("detailstab1");
    addTableCell("%hhdetails" + edit("99", HH2) + "%", 0);
    
    setTableCss("hhdetailstab" + edit("99", HH2), "detailstable2");
    
    summ(1,1) = summ(1,1) + 1;
    
    hhCount = hhCount + 1;
    pbHhIdx(hhCount) = HH2;
  endif;

  

  foundHh(HH2) = foundHh(HH2) + 1; 

  string hhn = edit("99", HH2); 
  string intn = edit("999", HH3); 

  setLabel("hhdetails" + hhn, "%hhdetailstab" + hhn + "%");
  
  //Ajout des ménages dans les lignes
  addTableRow("hhdetailstab" + hhn);
  
  string hhDetails;
  
  hhDetails = "Addresse : " + strip(HHADDR) + lbr; //!T
  
  hhDetails = hhDetails + "Chef de méange : " + strip(HHNAME) + lbr; //!T

  if !special(HH2) & hhIntAssign(HH2) > 0 then
    
    hhDetails = hhDetails + "Assigné à : " + edit("999", hhIntAssign(HH2)) + lbr; //!T
    
  else
    
    hhDetails = hhDetails + "Non encore assigné " + lbr; //!T    

  endif;
  
  hhDetails = hhDetails + "Enquêté par : " + edit("999", HH3) + lbr; //!T

  numeric part = partialH();

  if part then
    
    hhDetails = hhDetails + "Resultat : Partiel (Modif)"; //!T
    
    summ(1, 4) = summ(1, 4) + (foundHh(HH2) = 1);
    
  elseif HH46 = 1 then
    
    hhDetails = hhDetails + "Resultat: 01) Complet " + lbr; //!T
    
    summ(1, 2) = summ(1, 2) + (foundHh(HH2) = 1);
    
   
  else
    
    hhDetails = hhDetails + "Result: " + edit("99", HH46) + ") " + getlabel(HH46, HH46) + lbr; //!T
    
    summ(1, 3) = summ(1, 3) + (foundHh(HH2) = 1);
  endif;
  
       summ(1, 5) = summ(1, 1) - (summ(1, 2) + summ(1, 3) + summ(1, 4) )  ;  // Ménages non enqutés
  
  //duplicated household
  numeric dupl = 0;
  if foundHh(HH2) > 1 then
    hhDetails = hhDetails + div("Dupliqué !!!", "redBold") + lbr;
    duplHh(HH2, HH3) = 1;
    dupl = 1;

    writeError(50040, 1, "Ménage dupliqué " + edit("99", HH2)); //!T

  endif;

  //adding separator
  hhDetails = hhDetails + "%separator%";

  addTableCell(hhDetails, 0);

  if !dupl then
    pbHh(HH2, 1) = !part; 
    pbHh(HH2, 2) = 1;    
  endif;
  
  if part then exit; endif;

  addTableRow("hhdetailstab" + hhn);
 
  numeric eligCount = 0;
 
