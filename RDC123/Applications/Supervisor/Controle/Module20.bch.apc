{Application 'MODULE20' logic file generated by CSPro}
PROC GLOBAL

set explicit ;
alpha(26) alphavar;				   { Alpha working variable used in checking alpha vars }
alpha(26) alphanew;                { Alpha working variable used in checking alpha vars }
alpha(62) alphalst;                { The alphabet }
numeric x;

function alphachk(alpha(26) alphamask);
{  russian_convert();}
  { first remove all blanks, and duplicate question marks }
  alphanew = "";
 numeric  qmark = 0;
 numeric  lx = 1  l  a ;
  do l = 1 while l <= length(strip(alphavar))
    if alphavar[l:1] <> " " and (alphavar[l:1] <> "?" or not qmark) then
      alphanew[lx:1] = alphavar[l:1];
      lx = lx + 1;
      if alphavar[l:1] = "?" then
        qmark = 1;
      endif;
    endif;
  enddo;
  { aok = 0 - string is bad, aok = 1 - string is good }
numeric   totlen = length(strip(alphamask));
 numeric  aok = 0;           { assume string is bad - for empty string }
 numeric alphsize = length(strip(alphanew));
  if alphsize then   { not empty string }
    { check for "?" as only character }
    aok = (alphanew[1:1] = "?" and alphsize = 1);
    if !aok then     { if not a single "?", check string }
      aok = 1;       { now assume string is good until we know otherwise }
      l = 1;         { l is position in string of acceptable values }
      a = 1;         { a is position in input string }
      { loop while the string is still good and there are more letters }
      while aok and a <= alphsize do
        aok = pos(alphanew[a:1],alphamask[l:totlen-l+1]);
        if aok then     { letter is acceptable }
          l = l + aok;  { increment l to position after letter in string of acceptable values }
          a = a + 1     { increment a to next letter in input string }
        endif;
      enddo;
    endif;
  endif;
  alphachk = (!aok);    { alphachk = 0 - if string is good, = 1 - if string is bad }
  { now expand variables }
  if aok then
    do l = 1 while l <= length(strip(alphamask))
      if pos(alphamask[l:1],alphanew) then
        alphavar[l:1] = alphamask[l:1]
      elseif pos("?",alphanew) then
        alphavar[l:1] = "?"
      else
        alphavar[l:1] = " "
      endif;
    enddo;
  endif;
end;

PROC EPMU1M20_FF

PROC M201

 errmsg("ERREURS DU MODULE 20 : DEPENSES EFFECTUEES A L'OCCASION DE FETES OU  CEREMONIES AU CORS DES 12 DERNIERS MOIS ");
 errmsg("=============================================================================================================");

PROC M2011

x = totocc(DEP_FETES_EDT) ;

  if $ <> 1 then
    
    if x > 0 then
    	errmsg(117001,M201,M202,20,"M2011",M20INT);
    endif;
  endif;
PROC M2017

if FEQ01>0 and not FEQ10(totocc(MOD20_EDT))<>0 then
	errmsg("Ce module est partiellement enquêté")
endif;
PROC M20FIN

PROC FEQ01

if $ <> x and $>=0 then 
	errmsg(027001,M201,M202,20,"FEQ01",M20INT,$,x);
endif;
PROC FEQ03

if not invalueset(FEQ03, FEQ03_VS1) and not special($) then
	errmsg(111111,M201,M202,20,"FEQ03",M20INT);
endif;
PROC FEQ04

if not invalueset(FEQ04, FEQ04_VS1) and not special($)  then
	errmsg(111111,M201,M202,20,"FEQ04",M20INT);
endif;

if FEQ03 = 9 and FEQ04 <> 12 then 
	errmsg(040301,M201,M202,20,"FEQ04",M20INT);
endif;

if FEQ03 = 3 and FEQ04 <> 1 then 
	errmsg(040302,M201,M202,20,"FEQ04",M20INT);
endif;
PROC FEQ06

if not invalueset(FEQ06, FEQ06_VS1) and not special($)  then
	errmsg(111111,M201,M202,20,"FEQ06",M20INT);
endif;
PROC FEQ07

if $<> notappl and $ < 1000 then
	errmsg(070001,M201,M202,20,"FEQ07",M20INT,$)
endif;
	
if $<> notappl and $%50 <> 0  then
	errmsg(070002,M201,M202,20,"FEQ07",M20INT,$);
endif;
PROC FEQ08

if not invalueset(FEQ08, FEQ08_VS1) and not special($)  then
	errmsg(111111,M201,M202,20,"FEQ08",M20INT);
endif;
PROC FEQ09

if FEQ08>1 AND (not invalueset(FEQ09, FEQ09_VS1) and not special($) ) then
	errmsg(111111,M201,M202,20,"FEQ09",M20INT);
endif;

if (FEQ08  in 0,1) and (FEQ09 <> notappl) then 
	errmsg(090801,M201,M202,20,"FEQ09",M20INT);
endif;
PROC FEQ09A

if not invalueset(FEQ09A, FEQ09A_VS1) and not special($)  then
	errmsg(111111,M201,M202,20,"FEQ09A",M20INT);
endif;

if ((FEQ03 in 1:3) or (FEQ03=9) or (FEQ03=11) or (FEQ03>13))and (FEQ09A <> 1) and FEQ09A<>notappl then
	errmsg(090391,M201,M202,20,"FEQ09A",M20INT);
endif;

if ((FEQ03 in 5:8) or (FEQ03=10) or (FEQ03=13)) and (FEQ09A <> 2) then
	errmsg(090392,M201,M202,20,"FEQ09A",M20INT);
endif;

if (FEQ03 = 4) and (FEQ09A <> 3) then
	errmsg(090393,M201,M202,20,"FEQ09A",M20INT);
endif;

if not invalueset(FEQ09A, FEQ09A_VS1) and (FEQ03 in 1:11) and not special($)  then 
	errmsg(090394,M201,M202,20,"FEQ09A",M20INT);
endif; 

if not invalueset(FEQ09A, FEQ09A_VS2) and ((FEQ03 in 12:13) OR (FEQ03=15)) and not special($)  then 
	errmsg(090395,M201,M202,20,"FEQ09A",M20INT);
endif;

if not invalueset(FEQ09A, FEQ09A_VS3) and (FEQ03 =	15) and not special($)  then 
	errmsg(090396,M201,M202,20,"FEQ09A",M20INT);
endif;
PROC FEQ10

if not invalueset(FEQ10, FEQ10_VS1) and not special($)  then
	errmsg(111111,M201,M202,20,"FEQ10",M20INT);
endif;
