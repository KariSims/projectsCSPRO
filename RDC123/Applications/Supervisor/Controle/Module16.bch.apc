{Application 'MODULE16' logic file generated by CSPro}
PROC GLOBAL

set explicit;
{ Definitions of working variables }
array alpha(8) KishGrid(10);	   { Grid used for selection of child for child discipline module }
alpha(26) alphavar;				   { Alpha working variable used in checking alpha vars }
alpha(26) alphanew;                { Alpha working variable used in checking alpha vars }
alpha(62) alphalst;                { The alphabet }
array codes(50);                   { Array used for creating line numbers of household members sleeping under mosquito net}
array alpha(50) labels(50);        { Array used for creating names of household members sleeping under mosquito net} 
alpha(40) yname, ynamehh, tmpname; { List of names for questions }
alpha(900) strnotes;               { for editnote at the end of the interview }
alpha(40) worklabel;               { Alpha variable to get customize text for questions }
numeric Incrm1 i ;


function alphachk(alpha(26) alphamask);
{  russian_convert();}
  { first remove all blanks, and duplicate question marks }
  alphanew = "";
 numeric  qmark = 0 ;
 numeric  lx = 1  l  a ;
  do l = 1 while l <= length(strip(alphavar))
    if alphavar[l:1] <> " " and (alphavar[l:1] <> "?" or not qmark) then
      alphanew[lx:1] = alphavar[l:1];
      lx = lx + 1;
      if alphavar[l:1] = "?" then
        qmark = 1;
      endif;
    endif;
  enddo;
 { aok = 0 - string is bad, aok = 1 - string is good }
numeric   totlen = length(strip(alphamask));
 numeric  aok = 0;           { assume string is bad - for empty string }
 numeric alphsize = length(strip(alphanew));
  if alphsize then   { not empty string }
    { check for "?" as only character }
    aok = (alphanew[1:1] = "?" and alphsize = 1);
    if !aok then     { if not a single "?", check string }
      aok = 1;       { now assume string is good until we know otherwise }
      l = 1;         { l is position in string of acceptable values }
      a = 1;         { a is position in input string }
      { loop while the string is still good and there are more letters }
      while aok and a <= alphsize do
        aok = pos(alphanew[a:1],alphamask[l:totlen-l+1]);
        if aok then     { letter is acceptable }
          l = l + aok;  { increment l to position after letter in string of acceptable values }
          a = a + 1     { increment a to next letter in input string }
        endif;
      enddo;
    endif;
  endif;
  alphachk = (!aok);    { alphachk = 0 - if string is good, = 1 - if string is bad }
  { now expand variables }
  if aok then
    do l = 1 while l <= length(strip(alphamask))
      if pos(alphamask[l:1],alphanew) then
        alphavar[l:1] = alphamask[l:1]
      elseif pos("?",alphanew) then
        alphavar[l:1] = "?"
      else
        alphavar[l:1] = " "
      endif;
    enddo;
  endif;
end;


PROC EPMU1M16_FF

PROC M161

 errmsg("ERREURS MODULE 16 : MIGRATION )");
 errmsg("==============================)");
PROC M1611

if not invalueset(M1611) then
	errmsg(160001 , M161, M162, 16, M16HINT, M1611, "M1611"); 
endif;


if M1611 = 2 then 
	errmsg(160002 , M161, M162, 16, M16HINT, getlabel($,$));
endif;


if $ <> 1 then
	 if totocc (MOD16_1_EDT) > 0 then
	  	errmsg(160003 , M161, M162, 16, M16HINT);
	 endif;
endif; 
PROC M1617

if M1617= notappl then
	errmsg(160004, M161, M162, 16, M16HINT)
endif;
PROC MIT01
if not invalueset(MIT01) then
	errmsg(010005 , M161, M162, 16, M16HINT, MIT01, "MIT01"); 
endif;


if MIT01 = 2 then 
	errmsg(010006 , M161, M162, 16, M16HINT, getlabel($,$));
endif;


if MIT01 = 2 then

	if totocc (MOD16_1_EDT) > 0 then
		errmsg(010007 , M161, M162, 16, M16HINT);
	endif; 
endif;
PROC MIT01N
if MIT01 = 1 and (MIT01N = 0 or notappl) then
	errmsg(010008, M161, M162, 16, M16HINT)
endif;
PROC MIT25
if not invalueset(MIT25) then
	errmsg(250009 , M161, M162, 16, M16HINT, getlabel($,$), "MIT25" ); 
endif;


if MIT25 = 2 then 
	errmsg(250010 , M161, M162, 16, M16HINT, getlabel($,$));
endif;


if MIT25 = 2 then

	if totocc (MOD16_2_EDT) > 0 then
		errmsg(250011 , M161, M162, 16, M16HINT);
	endif; 
endif;
PROC MIT25N
if MIT25 = 1 and (MIT25N = 0 or notappl) then
	errmsg(250012, M161, M162, 16, M16HINT)
endif;

PROC MIT38
if not invalueset(MIT25) then
	errmsg(390013 , M161, M162, 16, M16HINT, getlabel($,$), "MIT25" ); 
endif;


if MIT38 = 2 then 
	errmsg(390014 , M161, M162, 16, M16HINT, getlabel($,$));
endif;


if MIT38 = 2 then

	if totocc (MOD16_3_EDT) > 0 then
		errmsg(390015 , M161, M162, 16, M16HINT);
	endif; 
endif;
PROC MIT38N
if MIT38 = 1 and (MIT38N = 0 or notappl) then
	errmsg(390016, M161, M162, 16, M16HINT)
endif;

PROC MIT3
// Prendre les données dans le menage
 HH1=M161;
 HH2=M162;
 HINT = M16INT ;
 HLN = 0;
 
if  loadcase(EPMU1,HH1,HH2,HINT,HLN) then
	numeric v ;
	v = 2018 - M08(1) +12 ;
	errmsg(037001, M161, M162, 16, M16HINT)
endif;
PROC MIT3A
if MIT3 <> 2017 then
errmsg(037002 , M161, M162, 16, M16HINT, MIT1_2) ;
endif;
PROC MIT3B
if not invalueset(MIT3B) then
	errmsg(037028 , M161, M162, 16, M16HINT, getlabel($,$), "MIT3B" ); 
endif;
PROC MIT4
if not invalueset(MIT4) then
	errmsg(047003 , M161, M162, 16, M16HINT, getlabel($,$), "MIT4" ); 
endif;
PROC MIT5
if not invalueset(MIT5) then
	errmsg(057004 , M161, M162, 16, M16HINT, getlabel($,$), "MIT5" ); 
endif;
PROC MIT6
if not invalueset(MIT6) then
	errmsg(067005 , M161, M162, 16, M16HINT, getlabel($,$), "MIT6" ); 
endif;
PROC MIT7
if not invalueset(MIT7) then
	errmsg(077006 , M161, M162, 16, M16HINT, getlabel($,$), "MIT7" ); 
endif;
PROC MIT8
if not invalueset(MIT8) then
	errmsg(087007 , M161, M162, 16, M16HINT, getlabel($,$), "MIT8" ); 
endif;
PROC MIT9A
if not invalueset(MIT9A) then
	errmsg(097008 , M161, M162, 16, M16HINT, getlabel($,$), "MIT9A" ); 
endif;

if MIT3 <> 2017 and ( MIT9A <> 2018 - MIT3) then 
errmsg(097009 , M161, M162, 16, M16HINT);
endif;

if MIT9A  > 0 then skip to MIT10 endif;
PROC MIT9M
if not invalueset(MIT9M) then
	errmsg(097010 , M161, M162, 16, M16HINT, getlabel($,$), "MIT9M" ); 
endif;

if MIT3=2018 and M166M < MIT9M then
 errmsg(097011 , M161, M162, 16, M16HINT);
endif;
PROC MIT10
if not invalueset(MIT10) then
	errmsg(107012 , M161, M162, 16, M16HINT, getlabel($,$), "MIT10" ); 
endif;
PROC MIT11
if not invalueset(MIT11) then
	errmsg(117013 , M161, M162, 16, M16HINT, getlabel($,$), "MIT11" ); 
endif;
PROC MIT12
if not invalueset(MIT12) then
	errmsg(127014 , M161, M162, 16, M16HINT, getlabel($,$), "MIT12" ); 
endif;
PROC MIT13
if not invalueset(MIT13) then
	errmsg(137015 , M161, M162, 16, M16HINT, getlabel($,$), "MIT13" ); 
endif;
PROC MIT14
if not invalueset(MIT14) then
	errmsg(147016 , M161, M162, 16, M16HINT, getlabel($,$), "MIT14" ); 
endif;
PROC MIT15
if not invalueset(MIT15) then
	errmsg(157017 , M161, M162, 16, M16HINT, getlabel($,$), "MIT15" ); 
endif;
PROC MIT16
if MIT16 in 111101:111108 then
errmsg(167018 , M161, M162, 16, M16HINT, strip(MIT1_2)) ;
endif;

if not invalueset(MIT15) then
	errmsg(167019 , M161, M162, 16, M16HINT, getlabel($,$), "MIT15" ); 
endif;
PROC MIT17
if not invalueset(MIT17) then
	errmsg(177020 , M161, M162, 16, M16HINT, getlabel($,$), "MIT17" ); 
endif;
PROC MIT17A
if not invalueset(MIT17A) then
	errmsg(177029 , M161, M162, 16, M16HINT, getlabel($,$), "MIT17A" ); 
endif;
PROC MIT17B
if not invalueset(MIT17B) then
	errmsg(177030 , M161, M162, 16, M16HINT, getlabel($,$), "MIT17B" ); 
endif;
PROC MIT18
if not invalueset(MIT18) then
	errmsg(187021 , M161, M162, 16, M16HINT, getlabel($,$), "MIT18" ); 
endif;

PROC MIT19
if alphachk("ABCDEFGX") then
    errmsg(207022 , M161, M162, 16, M16HINT);
 else
    MIT19 = alphavar;
 endif;
  
if pos("X",MIT19) then
     editnote();
    if length (strip(editnote()))< 2 then
  		errmsg(207023 , M161, M162, 16, M16HINT);
	endif;
endif;
PROC MIT21
if not invalueset(MIT21) then
	errmsg(217024 , M161, M162, 16, M16HINT, getlabel($,$), "MIT21" ); 
endif;
PROC MIT22
if not invalueset(MIT22) then
	errmsg(227025 , M161, M162, 16, M16HINT, getlabel($,$), "MIT22" ); 
endif;
PROC MIT23
if not invalueset(MIT23) then
	errmsg(237026 , M161, M162, 16, M16HINT, getlabel($,$), "MIT23" ); 
endif;
PROC MIT24
if not invalueset(MIT24) then
	errmsg(247027 , M161, M162, 16, M16HINT, getlabel($,$), "MIT24" ); 
endif;
PROC MIT25A

Incrm1=1 ;
i=Incrm1+1 ;

while Incrm1 < totocc(MOD16_2_EDT) do
	while i<=totocc(MOD16_2_EDT) do
		if MIT25A(Incrm1)=MIT25A(i) then 
			errmsg(257118,M161,M162,16,M16INT);
		endif;
		i=i+1;
	enddo;
	Incrm1=Incrm1+1;
	i=Incrm1+1;
enddo;
PROC MIT26
if not invalueset(MIT26) then
	errmsg(267101 , M161, M162, 16, M16HINT, getlabel($,$), "MIT26" ); 
endif;
PROC MIT27M
if MIT27A =2018 and M166M < MIT27M then
	errmsg(277102 , M161, M162, 16, M16HINT);
endif;

PROC MIT28
if $ = 8 then
	 editnote();
    if length (strip(editnote()))< 2 then
  		errmsg(287103 , M161, M162, 16, M16HINT);
	endif;
Endif;

if not invalueset(MIT28) then
	errmsg(287104 , M161, M162, 16, M16HINT, getlabel($,$), "MIT28" ); 
endif;
PROC MIT29
if not invalueset(MIT29) then
	errmsg(297105 , M161, M162, 16, M16HINT, getlabel($,$), "MIT29" ); 
endif;

if $ = 8 then
	 editnote();
    if length (strip(editnote()))< 2 then
  		errmsg(297106 , M161, M162, 16, M16HINT);
	endif;
endif;

if MIT29 = MIT28 then    // c'est bien
else
errmsg(297107 , M161, M162, 16, M16HINT) ;
endif ;
PROC MIT30
if not invalueset(MIT30) then
	errmsg(307108 , M161, M162, 16, M16HINT, getlabel($,$), "MIT30" ); 
endif;
PROC MIT31
if not invalueset(MIT31) then
	errmsg(317109 , M161, M162, 16, M16HINT, getlabel($,$), "MIT31" ); 
endif;
PROC MIT32
if not invalueset(MIT32) then
	errmsg(327110 , M161, M162, 16, M16HINT, getlabel($,$), "MIT32" ); 
endif;

if MIT32 < MIT31 and MIT31 in 0:5 then
  errmsg(327111 , M161, M162, 16, M16HINT);
endif;
PROC MIT33
if not invalueset(MIT33) then
	errmsg(337112 , M161, M162, 16, M16HINT, getlabel($,$), "MIT33" ); 
endif;
PROC MIT34
if not invalueset(MIT34) then
	errmsg(347113 , M161, M162, 16, M16HINT, getlabel($,$), "MIT34" ); 
endif;

if MIT33 in 111101:111108 then
	errmsg(347114 , M161, M162, 16, M16HINT, strip(MIT25B)); 
endif;
PROC MIT35
if not invalueset(MIT35) then
	errmsg(357115 , M161, M162, 16, M16HINT, getlabel($,$), "MIT35" ); 
endif;
PROC MIT36
if not invalueset(MIT36) then
	errmsg(367116 , M161, M162, 16, M16HINT, getlabel($,$), "MIT36" ); 
endif;
PROC MIT37
if not invalueset(MIT37) then
	errmsg(377117 , M161, M162, 16, M16HINT, getlabel($,$), "MIT37" ); 
endif;
PROC MIT1_B
Incrm1=1 ;
i=Incrm1+1 ;

while Incrm1 < totocc(MOD16_3_EDT) do
	while i<=totocc(MOD16_3_EDT) do
		if MIT1_B(Incrm1)=MIT1_B(i) then 
			errmsg(397213,M161,M162,16,M16INT);
		endif;
		i=i+1;
	enddo;
	Incrm1=Incrm1+1;
	i=Incrm1+1;
enddo;
PROC MIT39
if not invalueset(MIT39) then
	errmsg(397201 , M161, M162, 16, M16HINT, getlabel($,$), "MIT39" ); 
endif;
PROC MIT40
if not invalueset(MIT40) then
	errmsg(407202 , M161, M162, 16, M16HINT, getlabel($,$), "MIT40" ); 
endif;
PROC MIT41
if not invalueset(MIT41) then
	errmsg(417203 , M161, M162, 16, M16HINT, getlabel($,$), "MIT41" ); 
endif;
PROC MIT42
if not invalueset(MIT42) then
	errmsg(427204 , M161, M162, 16, M16HINT, getlabel($,$), "MIT42" ); 
endif;
PROC MIT44
if not invalueset(MIT44) then
	errmsg(447205 , M161, M162, 16, M16HINT, getlabel($,$), "MIT44" ); 
endif;
PROC MIT45
if not invalueset(MIT45) then
	errmsg(457206 , M161, M162, 16, M16HINT, getlabel($,$), "MIT45" ); 
endif;
PROC MIT46
if not invalueset(MIT46) then
	errmsg(467207 , M161, M162, 16, M16HINT, getlabel($,$), "MIT46" ); 
endif;
PROC MIT47
if not invalueset(MIT47) then
	errmsg(477208 , M161, M162, 16, M16HINT, getlabel($,$), "MIT47" ); 
endif;

if MIT47 in 111101:111108 then
errmsg(477209, M161, M162, 16, M16HINT,strip(MIT38A)) 
endif;
PROC MIT48
if not invalueset(MIT48) then
	errmsg(487210 , M161, M162, 16, M16HINT, getlabel($,$), "MIT48" ); 
endif;
PROC MIT49
if not invalueset(MIT49) then
	errmsg(497211 , M161, M162, 16, M16HINT, getlabel($,$), "MIT49" ); 
endif;

if MIT47 in 111101:111108 then
errmsg(497212, M161, M162, 16, M16HINT,strip(MIT38A)) 
endif;
