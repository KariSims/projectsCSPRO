 {Application 'CAPIND' logic file generated by CSPro}
PROC GLOBAL

set explicit
numeric t,i,j,x,e,addmode,hasHH,SP1, gr,reqst;

//file FichSaPart;
string strpart,ldep,type,libelle;
array codes(50) ;
array alpha(30) labels(50);
alpha(900) strnotes; 

// fonction pour la mise en forme de message d'erreur
function erreur(string message)
    setfont(Errmsg,"Baskerville Old Face", 24,bold);
	errmsg("%s",message)
end;
function clear_labels();
	do i = 1 while i <= 50
	  codes(i) = notappl;
	  labels(i) = "";
	enddo;
end;

{Function rech_departement()
	open(DICT_DR_DICT);

		DICT_DR_ID = 1;

	reqst = loadcase(DICT_DR_DICT,DICT_DR_ID);

			j = 1;

			do varying i=1 until i> 96
			numeric cl=i+1;
				if I01 = REG_ID(i) then
					if DEPART_ID(cl) <> DEPART_ID(i) then
						labels(j)=strip(NOM_DEPART(i));
						codes(j)=DEPART_ID(i);
							j = j + 1;
					endif;
				endif;
			enddo;
	close (DICT_DR_DICT);
end;
Function rech_DR()
	open(DICT_DR_DICT);

		DICT_DR_ID = 1;

	reqst = loadcase(DICT_DR_DICT,DICT_DR_ID);

			j = 1;

			do varying i=1 until i> 96
			numeric cl=i+1;
				if I01 = REG_ID(i) & I02 = DEPART_ID(i) then
					if DR_ID(cl)<>DR_ID(i) then
						labels(j)="I04"+" "+"N°_"+edit("9999",DR_ID(i));
						codes(j)=DR_ID(i);
							j = j + 1;
					endif;
				endif;
			enddo;
	close (DICT_DR_DICT);
end;
Function rech_localite()
	open(DICT_DR_DICT);

		DICT_DR_ID = 1;

	reqst = loadcase(DICT_DR_DICT,DICT_DR_ID);

			j = 1;

			do varying i=1 until i> 96
			numeric cl=i+1;
				if I01 = REG_ID(i) & I02 = DEPART_ID(i) & I04 = DR_ID(i) then
					if LOCALIT_ID(cl)<>LOCALIT_ID(i) then
						labels(j)="Localité"+" "+"N°_"+edit("9999",LOCALIT_ID(i));
						codes(j)=LOCALIT_ID(i);
							j = j + 1;
					endif;
				endif;
			enddo;
	close (DICT_DR_DICT);
end;

Function rech_quartier()
	open(DICT_DR_DICT);

		DICT_DR_ID = 1;

	reqst = loadcase(DICT_DR_DICT,DICT_DR_ID);

			j = 1;

			do varying i=1 until i> 96
			numeric cl=i+1;
				if I01 = REG_ID(i) & I02 = DEPART_ID(i) & I04 = DR_ID(i) & I05 = LOCALIT_ID(i) then
					if QUART_ID(cl)<>QUART_ID(i) then
						labels(j)=strip(NOM_QUART(i));
						codes(j)=QUART_ID(i);
							j = j + 1;
					endif;
				endif;
			enddo;
	close (DICT_DR_DICT);

end;

Function rech_ilot()
	open(DICT_DR_DICT);

		DICT_DR_ID = 1;

	reqst = loadcase(DICT_DR_DICT,DICT_DR_ID);

			j = 1;

			do varying i=1 until i> 96
			numeric cl=i+1;
				if I01 = REG_ID(i) & I02 = DEPART_ID(i) & I04 = DR_ID(i) & I05 = LOCALIT_ID(i) & I06 = QUART_ID(i) then
					if N_ILOT_ID(cl)<>N_ILOT_ID(i) then
						labels(j)="Ilot"+" "+"N°_"+edit("9999",N_ILOT_ID(i));
						codes(j)=N_ILOT_ID(i);
							j = j + 1;
					endif;
				endif;
			enddo;
	close (DICT_DR_DICT);
end;}

//Function to associate dicts
function Head_call()

open(QUESTIONNAIRE_MENAGE_DICT);
	I01=REGION;
	I02=DEPARTEMENT;
	I03=MILIEU_DE_RESIDENCE;
	I04=DR;
	I05=LOCALITTE;
	I06=QUARTIER;
	I07=N_DE_L_ILOT;
	I08=GRAPPE;
	I09=MENAGE;

hashh = loadcase(QUESTIONNAIRE_MENAGE_DICT,I01,I02,I03,I04,I05,I06,I07,I08,I09);
end;

function footer_call()
	close (QUESTIONNAIRE_MENAGE_DICT);
	if j = 1 then
		errmsg("Aucun individu dans le Ménage");
		stop(-1);
	endif;
end;

// sauvegarde des données 
Function sav()
	savepartial();
end;


// Quitter
Function quitter()
	savepartial();
	stop(1) ;
end;

  { creation d'une barre basic }
  function userbase();
    userbar( clear );

    
    userbar(add text,"QUESTIONNAIRE INDIVIDU");
	userbar(set color,180,120,150);
	
    userbar( add button, "<",    do("PreviousField") );
    userbar( add button, ">",    do("NextField") );	
    userbar( add button, "Note", do("EditNote") );  
 	userbar(add spacing,25);   
	userbar(add button,"Sauvegarde", sav());    
	userbar(add spacing,25);
	userbar(add text," ");
	
	userbar(add button,"Quitter", quitter());    
	userbar(add spacing,25);
	userbar(add text," ");
  end;
PROC QUESTIONNAIRE_INDIVIDU_FF
preproc
setfont (valuesets, "Baskerville Old Face", 26,bold);
setfont(ErrMsg,"Baskerville Old Face",32);
setfont(userbar,"Baskerville Old Face",25,bold);
userbase();
userbar(show);
if demode()=add then addmode=1; endif;
if demode()=modify then addmode=2; endif;
PROC I09
preproc
setfont(ErrMsg,"Baskerville Old Face",32);
//if demode() = add then 
	  x=errmsg("Selectionnez le ménage appartenant à la grappe choisie")
		select("Ok, poursuivre",continue);
//onfocus	 
	SP1=selcase(QUESTIONNAIRE_MENAGE_DICT,"")
		include(MENAGE,MH2) where I08=GRAPPE and MH2(1)<>"";

	if SP1=1 then
		I09=MENAGE;
		I01=REGION;
		I02=DEPARTEMENT;
		I03=MILIEU_DE_RESIDENCE;
		I04=DR;
		I05=LOCALITTE;
		I06=QUARTIER;
		I07=N_DE_L_ILOT;
		noinput;
	else 
		x=errmsg("Cette grappe  ne contient pas de menage renseigné")
		  select("CHANGER DE GRAPPE",I08,"FERMER L'APPLICATION",continue);
				if x = 2 then
					stop(1);
				endif;
	endif;
//	Advance to I11;

//endif;

postproc
if not $ in 1:10 then
  errmsg("le numero des menages vont de 1 à 5 ");
  reenter;
endif;
PROC I11
Preproc
clear_labels();

//onfocus
Head_call();

	if !hashh then
//		  errmsg(0009, HH1, HH2,HLN);
	  stop(-1);
	  
	 else

	    j = 1;

	  	do varying i=1 until i> SUP2
			if MH5(i) > 0 then
				codes(j)= MH1(i);
				labels(j)= strip(MH2(i));
			   j = j + 1;
			endif;  
		enddo;
		
	endif;

footer_call();
	
setvalueset(@getsymbol(),codes,labels);
setcapturetype($,3);

Postproc	
	Do varying j = 0 until j >= i
		if codes(j) = I11 then
			I12 = labels(j);
			I10=MH2(1) //You must put the head hh in the first place to hh
		endif;
	enddo;
	Advance to QUOTQ01JJ1;// ELG;
PROC I01
postproc
If !invalueset($) then
	errmsg("Valeur Invalide");
//	reenter;
endif;
PROC QUOTQ01JJ1
preproc
if demode() = add then 
	if special(visualvalue($)) then
	    x = sysdate();
	    if QUOTQ01JJ1 = notappl then QUOTQ01JJ1 = sysdate( "DD" );endif;
	    if QUOTQ01MJ1 = notappl then QUOTQ01MJ1 = sysdate( "MM" );endif;
	    if QUOTQ01AJ1 = notappl then QUOTQ01AJ1 = sysdate( "YYYY" );endif;
	endif;
endif;
PROC ELG
preproc
Head_call();

	if !hasHH then
		  errmsg("SP");
	  stop(-1);
	  
	 else

		ELG=SUP2;
		
	endif;

footer_call();
noinput;
PROC INF_IND000
preproc
Head_call();

	if !hashh then
//		  errmsg(0009, HH1, HH2,HLN);
	  stop(-1);
	  
	 else

	    j = 1;
//		ELG=SUP2;
	  	do varying i=1 until i> SUP2
			if MH1(i)>0 then
				IND_NUM(j)=MH1(i);
				IND_NOM(j)=strip(MH2(i));
			   j = j + 1;
			endif;  
		enddo;
		
	endif;

footer_call();
PROC IND_NUM
preproc
noinput;
PROC IND_NOM
preproc
noinput;
PROC IND_CONSENTEMENT


preproc
if IND_CONSENTEMENT(1)=1 then 
do varying i=2 until i > ELG
IND_CONSENTEMENT(i)=1;noinput;advance to PERS_CONS;enddo;endif;

if IND_CONSENTEMENT(1)=2 then 
do varying i=2 until i > ELG
IND_CONSENTEMENT(i)=2;noinput;endlevel;enddo;endif;
PROC JO
PREPROC
$=1;
noinput;
PROC PERS_CONS
Preproc
PERS_CONS=count(INF_IND000 where IND_CONSENTEMENT = 1);

PROC COHEC
preproc
$=5;
if PERS_CONS > 0 then 
move to A0(1);
noinput;
endif;
if PERS_CONS = 0 then 
move to RES;
noinput;
endif;

postproc
move to A0(JO);
PROC A0
preproc
clear_labels();

Onfocus

	t = 1;

If special(A0) then	
	do varying i=1 until i> ELG
    numeric cl=0;
		for j in SECTA000 do		 	      
			if A0(j) = IND_NUM(i) then
				cl=1 ;
	        endif;
	    enddo;
	
		if cl=0 & special(A0(j)) then
			codes(t) = IND_NUM(i);
			labels(t) = strip(IND_NOM(i));
			t = t + 1; 
		endif;
		
	enddo;
else
		noinput;
endif;    
    SetValueSet( @GetSymbol(),codes,labels);
	setcapturetype(A0,3);
	
postproc
	Do varying j = 0 until j >= i
		if codes(j) = A0 then
			A0N = labels(j);
		endif;
	enddo;
	Advance to A1;
PROC A1
Preproc
clear_labels();
Head_call();

	if !hashh then
//		  errmsg(0009, HH1, HH2,HLN);
	  stop(-1);
	  
	 else
	 
	  	do varying i=1 until i> SUP2
			if A0(curocc())= MH1(i) & strip(A0N(curocc()))=strip(MH2(i)) then
				A1(curocc())=MH3(i);
				A2(curocc())=MH5(i);
				A3J(curocc())=MH6J(i);
				A3M(curocc())=MH6M(i);
				A3A(curocc())=MH6A(i);
				A3AGE(curocc())=MH7(i);
				A6(curocc())=MH8(i);
			endif;  
		enddo;
		
	endif;

footer_call();

setvalueset(@getsymbol(),codes,labels);
setcapturetype($,3);
noinput;
PROC A2
preproc
noinput;
PROC A3J
preproc
noinput;
PROC A3M
preproc
noinput;
PROC A3A
preproc
noinput;
PROC A3AGE
preproc
noinput;
PROC A4
preproc

if A3AGE in 10:14 then
	$ = 1;
	advance to A5;
Endif;

postproc

if A2 = 2 and  A4 in 1,5,6 then
	errmsg("%s ne peux etre %s",strip(A0N),getlabel($,$));
	reenter;
endif;
PROC A6
preproc
noinput;
PROC A8
postproc
if A7=2 and $ in 5,6 then
errmsg("une personne qui ne sait pas lire ne peut pas avoir un niveau %s",getlabel($,$));
reenter;
endif;
PROC A9
postproc
if $ <> 1 then
skip to A11;
endif;
PROC A10
postproc

if A9=1 and $=notappl then
errmsg("Veillez préciser le secteur d'activité de %s",strip(A0N));
reenter;
endif;
PROC A11
postproc

if A11=2 then 
advance to B1(count(SECTA000));
endif;
PROC A12
postproc
if A11=1 and $=notappl then
errmsg("Veillez renseigner le temps");
reenter;
endif;
move to  B0(count(SECTA000));
PROC SECTB000

PROC B0
preproc
B0(curocc())=A0(curocc());
B0N(curocc()) = A0N(curocc());
advance to B1;
noinput;
PROC B1
postproc
if $=notappl then
errmsg("ce champ ne peut être vide ");
reenter;
endif
PROC B2
postproc
if $=notappl then
errmsg("ce champ ne peut être vide ");
reenter;
endif;

if $=2 then 
B3=notappl;
B4=notappl;
B6=notappl;
B7=notappl;
B7_X="";
skip to B8;
endif;
PROC B3
postproc
if $=notappl then
errmsg("ce champ ne peut être vide ");
reenter;
endif
PROC B5
postproc
if length(strip(B5))=0 then
errmsg("veillez renseigner ce champ");
reenter;
endif;
if  !pos("X",B5)  then
skip to B6;
endif;
PROC B5_AUTRE
preproc
if  !pos("X",B5)  then
$="";
skip to B6;
endif;
postproc
if  !pos("X",B5) and length(strip($))>0 then
errmsg("veuillez effacer le contenu que vous avez ajouté");
reenter;
endif;
PROC B6
postproc
if $=notappl then
errmsg("ce champ ne peut être vide ");
reenter;
endif
PROC B7
postproc
if $=notappl then
errmsg("ce champ ne peut être vide ");
reenter;
endif;
if $<>3 then 
skip to B8;
endif;
PROC B7_X
preproc

if B7<>3 then 
$="";
skip to B8;
endif;
postproc
if length(strip($))<10 then
errmsg("Donnez plus de précison");
reenter;
endif;
PROC B8
postproc
if $=notappl then
errmsg("ce champ ne peut être vide ");
reenter;
endif;
if $ = 2 then
skip to B14;
endif;
PROC B9
postproc
if $=notappl then
errmsg("ce champ ne peut être vide ");
reenter;
endif
PROC B10
postproc
if $=notappl then
errmsg("ce champ ne peut être vide ");
reenter;
endif
PROC B11
postproc
if length(strip($))=0 then
errmsg("veillez renseigner ce champ");
reenter;
endif;
if  !pos("X",$)  then
skip to B12;
endif;
PROC B11_X
preproc
if  !pos("X",B11)  then
$="";
skip to B12;

endif;
postproc
if length(strip($))<10 then
errmsg("Donnez plus de précision");
reenter;
endif
PROC B12
postproc
if $=notappl then
errmsg("ce champ ne peut être vide ");
reenter;
endif;

if $<>4 then 
skip to B13;
endif;
PROC B12_X
preproc
if B12<>4 then 
$="";
skip to B13;
endif;
postproc
if length(strip($))<10 then
errmsg("Donnez plus de précison");
reenter;
endif;
PROC B13
postproc
if $ <> 3 then
skip to B14;
endif;
PROC B13_X
preproc
if B13 <> 3 then
$="";
skip to B14;
endif;

postproc

if B13<>3  and $<>""  then
errmsg("veillez effacer ce contenu");
endif;

if length(strip($))<10 then
errmsg("Donnez plus de précison");
reenter;
endif;
PROC B14
postproc
if $=notappl then
errmsg("ce champ ne peut être vide ");
reenter;
endif;

if $=2 then 
skip to B19;
endif;
PROC B15
postproc
if $=notappl then
errmsg("ce champ ne peut être vide ");
reenter;
endif;
PROC B16
postproc
if $=notappl then
errmsg("ce champ ne peut être vide ");
reenter;
endif;
PROC B17
postproc
type=getlabel($,$);
errmsg("%s",type);
if $=notappl then
errmsg("ce champ ne peut être vide ");
reenter;
endif;

if $<>8 then
skip to B18;
endif;

PROC B17_AUTRES
postproc
if length(strip($))<10 then
errmsg("Donnez plus de précison");
reenter;
endif;
libelle=strip($);
PROC B18
postproc
if B18<>3then
skip to B19;
endif;
PROC B18_X
postproc
if length(strip($))<10 then
errmsg("Donnez plus de précison");
reenter;
endif;

PROC B19
postproc
move to C0(count(SECTB000));
PROC SECTC000

PROC C0
preproc
C0(curocc())=A0(curocc());
C0N(curocc()) = A0N(curocc());
advance to C1;
noinput;
PROC C1
postproc
if $=notappl then
errmsg("ce champ ne peut être vide");
reenter;
endif;

if $=2 then
skip to C5;
endif;
PROC C2
postproc
if length(strip($))=0 then
errmsg("ce champ ne peut être vide");
endif;
if !pos("X",$) then
skip to C3;
endif;
PROC C2_X
postproc
if length(strip($))=0 then
errmsg("ce champ ne peut être vide");
reenter;
endif;
PROC C3
postproc
if length(strip($))=0 then
errmsg("ce champ ne peut être vide");
endif;
if !pos("X",$) then
skip to C4;
endif;
PROC C3_X
postproc
if length(strip($))=0 then
errmsg("ce champ ne peut être vide");
reenter;
endif;
PROC C4
postproc
if length(strip($))=0 then
errmsg("ce champ ne peut être vide");
endif;
if !pos("X",$) then
skip to C5;
endif;
PROC C4_X
postproc
if length(strip($))=0 then
errmsg("ce champ ne peut être vide");
reenter;
endif;

if length(strip($))<5 then
errmsg("donnez plus de précision");
reenter;
endif;
PROC C5
postproc
if $=2 then 
skip to C10;
endif;

PROC C6
postproc
if $=notappl then
errmsg("ce champ ne peut être vide");
reenter;
endif;
if $<>12 then
skip to C7;
endif;
PROC C6_X
postproc

if C6=12 and $ ="" then
errmsg("veillez remplir ce champ");
reenter;
endif;
PROC C7
postproc
if $=notappl then
errmsg("ce champ ne peut être vide");
reenter;
endif;
if $ = 2 then 
skip to C9;
endif;
PROC C8
postproc
if $=notappl then
errmsg("ce champ ne peut être vide");
reenter;
endif;

if $<>8 then
skip to C10;
endif;
PROC C8_X
postproc
if C8=8 and $="" then
errmsg("ce champ ne peut être vide");
endif;

if C8=8 and length(strip($))< 10 then
errmsg("donnez plus de précision");
reenter;
endif;
PROC C9
postproc
if $=notappl then
errmsg("ce champ ne peut vide");
endif;

if $<>6 then 
skip to C10;
endif;
PROC C9_X
preproc
if C9<>6 then
$="";
noinput;
endif;
advance to C10;

postproc
if C9=6 and $="" then
errmsg("ce champ ne peut être vide");
reenter;
endif;
PROC C10
postproc
if length(strip($))=0 then
errmsg("ce champ ne peut être vide");
reenter;
endif;
if !pos("X",$) then
skip to C11;
endif;
PROC C10_X
postproc
if length(strip($))=0 then
errmsg("ce champ ne peut être vide");
reenter;
endif;

if length(strip($))<5 then
errmsg("Donnez plus de précision");
reenter;
endif;
PROC C11
postproc
if $=notappl then
errmsg("ce champ ne peut être vide");
reenter;
endif;

if $<>5 then
skip to C12;
endif;
PROC C11_X
postproc
if length(strip($))=0 then
errmsg("ce champ ne peut être vide");
reenter;
endif;

if length(strip($))<5 then
errmsg("donnez plus de précision");
reenter;
endif;
PROC C12
postproc
if $=notappl then
errmsg("ce champ ne peut être vide");
reenter;
endif;
PROC C13
postproc
if $=notappl then
errmsg("ce champ ne peut être vide");
reenter;
endif;
PROC C14
postproc
if length(strip($))=0 then
errmsg("ce champ ne peut être vide");
reenter;
endif;
if !pos("X",$) then
skip to C15;
endif;
PROC C14_X
postproc
if length(strip($))=0 then
errmsg("ce champ ne peut être vide");
reenter;
endif;

if length(strip($))<5 then
errmsg("donnez plus de précision");
reenter;
endif;
PROC C15
postproc
if $=notappl then
errmsg("ce champ ne peut être vide");
reenter;
endif;
PROC C16
postproc
if length(strip($))=0 then
errmsg("ce champ ne peut être vide");
reenter;
endif;
if !pos("X",$) then
skip to C17;
endif;
PROC C16_X
postproc
if length(strip($))=0 then
errmsg("ce champ ne peut être vide");
reenter;
endif;

if length(strip($))<5 then
errmsg("donnez plus de précision");
reenter;
endif;
PROC C17
postproc
if $=notappl then
errmsg("ce champ ne peut être vide");
reenter;
endif;

if $<>3 then
skip to C18;
endif;
PROC C17_X
postproc
if length(strip($))=0 then
errmsg("ce champ ne peut être vide");
reenter;
endif;

if length(strip($))<5 then
errmsg("donnez plus de précision");
reenter;
endif;
PROC C18
postproc
if $=notappl then
errmsg("ce champ ne peut être vide");
reenter;
endif;
PROC C19
postproc
if $=notappl then
errmsg("ce champ ne peut être vide");
reenter;
endif;
PROC C20
postproc
if $=notappl then
errmsg("ce champ ne peut être vide");
reenter;
endif;
PROC C21
postproc
if $=notappl then
errmsg("ce champ ne peut être vide");
reenter;
endif;
PROC C22
postproc
if $=notappl then
errmsg("ce champ ne peut être vide");
reenter;
endif;
PROC C23
postproc
if length(strip($))=0 then
errmsg("ce champ ne peut être vide");
reenter;
endif;
if !pos("X",$) then
skip to C24;
endif;
PROC C23_X
postproc
if length(strip($))=0 then
errmsg("ce champ ne peut être vide");
reenter;
endif;

if length(strip($))<5 then
errmsg("donnez plus de précision");
reenter;
endif;
PROC C24
postproc
if $=notappl then
errmsg("ce champ ne peut être vide");
reenter;
endif;
if $<>7 then
skip to C25;
endif;
PROC C24_X
postproc
if length(strip($))=0 then
errmsg("ce champ ne peut être vide");
reenter;
endif;

if length(strip($))<5 then
errmsg("donnez plus de précision");
reenter;
endif;
PROC C25
postproc
if $=notappl then
errmsg("ce champ ne peut être vide");
reenter;
endif;
PROC C26
postproc
if $=notappl then
errmsg("ce champ ne peut être vide");
reenter;
endif;
PROC C27
postproc
if $=notappl then
errmsg("ce champ ne peut être vide");
reenter;
endif;
PROC C28
postproc
if $=notappl then
errmsg("ce champ ne peut être vide");
reenter;
endif;

if $<>2 then
skip to C29;
endif;
PROC C28_X
postproc
if length(strip($))=0 then
errmsg("ce champ ne peut être vide");
reenter;
endif;

if length(strip($))<5 then
errmsg("donnez plus de précision");
reenter;
endif;
PROC C29
postproc
if $=notappl then
errmsg("ce champ ne peut être vide");
reenter;
endif;
PROC C30
postproc
if $=notappl then
errmsg("ce champ ne peut être vide");
reenter;
endif;

if $<>4 then
skip to C31;
endif;
PROC C30_X
postproc
if length(strip($))=0 then
errmsg("ce champ ne peut être vide");
reenter;
endif;

if length(strip($))<5 then
errmsg("donnez plus de précision");
reenter;
endif;
PROC C31
postproc
if length(strip($))=0 then
errmsg("ce champ ne peut être vide");
reenter;
endif;
if !pos("X",$) then
skip to C32;
endif;
PROC C31_X
postproc
if length(strip($))=0 then
errmsg("ce champ ne peut être vide");
reenter;
endif;

if length(strip($))<5 then
errmsg("donnez plus de précision");
reenter;
endif;
PROC C32
postproc
if length(strip($))=0 then
errmsg("ce champ ne peut être vide");
reenter;
endif;
if !pos("X",$) then
skip to C33;
endif;
PROC C32_X
postproc
if length(strip($))=0 then
errmsg("ce champ ne peut être vide");
reenter;
endif;

if length(strip($))<5 then
errmsg("donnez plus de précision");
reenter;
endif;
PROC C33
postproc
if length(strip($))=0 then
errmsg("ce champ ne peut être vide");
reenter;
endif;
if !pos("X",$) then
move to D0(count(SECTC000));
endif;
PROC C33_X
preproc
move to D0(count(SECTC000));
postproc
if length(strip($))=0 then
errmsg("ce champ ne peut être vide");
reenter;
endif;

if length(strip($))<5 then
errmsg("donnez plus de précision");
reenter;
endif;
move to D0(count(SECTC000));
PROC D0
preproc
D0(curocc())=A0(curocc());
D0N(curocc()) = A0N(curocc());
advance to D1;
noinput;
PROC D0N
Preproc
advance to D1;
PROC D1
postproc
if $=notappl then
errmsg("ce champ ne peut être vide");
reenter;
endif;
PROC D2
postproc
if $=notappl then
errmsg("ce champ ne peut être vide");
reenter;
endif;

if $<>7 then
skip to D3;
endif;
PROC D2_X
postproc
if length(strip($))=0 then
errmsg("ce champ ne peut être vide");
reenter;
endif;

if length(strip($))<5 then
errmsg("donnez plus de précision");
reenter;
endif;
PROC D3
postproc
if $=notappl then
errmsg("ce champ ne peut être vide");
reenter;
endif;
PROC D4
postproc
if $=notappl then
errmsg("ce champ ne peut être vide");
reenter;
endif;
PROC D5
postproc
if $=notappl then
errmsg("ce champ ne peut être vide");
reenter;
endif;
PROC D6
postproc
if $=notappl then
errmsg("ce champ ne peut être vide");
reenter;
endif;
PROC D7
postproc
if length(strip($))=0 then
errmsg("ce champ ne peut être vide");
reenter;
endif;
if !pos("X",$) then
skip to D8;
endif;
PROC D7_X
postproc
if length(strip($))=0 then
errmsg("ce champ ne peut être vide");
reenter;
endif;

if length(strip($))<5 then
errmsg("donnez plus de précision");
reenter;
endif;
PROC D8
postproc
if $=notappl then
errmsg("ce champ ne peut être vide");
reenter;
endif;

if $<>7 then
skip to D9;
endif;
PROC D8_X
postproc
if length(strip($))=0 then
errmsg("ce champ ne peut être vide");
reenter;
endif;

if length(strip($))<5 then
errmsg("donnez plus de précision");
reenter;
endif;
PROC D9
postproc
if $=notappl then
errmsg("ce champ ne peut être vide");
reenter;
endif;

if $<>3 then
skip to D10;
endif;
PROC D9_X
postproc
if length(strip($))=0 then
errmsg("ce champ ne peut être vide");
reenter;
endif;

if length(strip($))<5 then
errmsg("donnez plus de précision");
reenter;
endif;
PROC D10
postproc
if $=notappl then
errmsg("ce champ ne peut être vide");
reenter;
endif;
PROC D11
postproc
if length(strip($))=0 then
errmsg("ce champ ne peut être vide");
reenter;
endif;
if !pos("X",$) then
skip to D12;
endif;
PROC D11_X
postproc
if length(strip($))=0 then
errmsg("ce champ ne peut être vide");
reenter;
endif;

if length(strip($))<5 then
errmsg("donnez plus de précision");
reenter;
endif;
PROC D12
postproc
if $=notappl then
errmsg("ce champ ne peut être vide");
reenter;
endif;
PROC D13
postproc
if $=notappl then
errmsg("ce champ ne peut être vide");
reenter;
endif;
PROC D14
postproc
if $=notappl then
errmsg("ce champ ne peut être vide");
reenter;
endif;
PROC D15
postproc
if $=notappl then
errmsg("ce champ ne peut être vide");
reenter;
endif;
PROC D16
postproc
if $=notappl then
errmsg("ce champ ne peut être vide");
reenter;
endif;

if $<>7 then
skip to D17;
endif;
PROC D16_X
postproc
if length(strip($))=0 then
errmsg("ce champ ne peut être vide");
reenter;
endif;

if length(strip($))<5 then
errmsg("donnez plus de précision");
reenter;
endif;
PROC D17
postproc
if $=notappl then
errmsg("ce champ ne peut être vide");
reenter;
endif;
PROC D18
postproc
if $=notappl then
errmsg("ce champ ne peut être vide");
reenter;
endif;

if $<>6 then
skip to D19;
endif;
PROC D18_X
postproc
if length(strip($))=0 then
errmsg("ce champ ne peut être vide");
reenter;
endif;

if length(strip($))<5 then
errmsg("donnez plus de précision");
reenter;
endif;
PROC D19
postproc
if $=notappl then
errmsg("ce champ ne peut être vide");
reenter;
endif;
PROC D20
postproc
if $=notappl then
errmsg("ce champ ne peut être vide");
reenter;
endif;
if $<>7 then
skip to D21;
endif;
PROC D20_X
postproc
if length(strip($))=0 then
errmsg("ce champ ne peut être vide");
reenter;
endif;

if length(strip($))<5 then
errmsg("donnez plus de précision");
reenter;
endif;
PROC D21
postproc
if $=notappl then
errmsg("ce champ ne peut être vide");
reenter;
endif;
PROC D22
postproc
if $<>8 and JO < ELG then
JO = JO+1;
move to COHEC;

elseif $<>8 and JO = ELG then
advance to RES;

endif;
PROC D22_X
preproc
if D22 <> 8 then
$="";
noinput;
endif;

postproc
if JO < ELG then
JO = JO+1;
move to COHEC;
elseif JO = ELG then
Move to RES;
Endif;
PROC RES
preproc
if IND_CONSENTEMENT(i) = 2  then
$=4;
noinput;
endif;
postproc
if $<>8 then
endgroup;
endif;
