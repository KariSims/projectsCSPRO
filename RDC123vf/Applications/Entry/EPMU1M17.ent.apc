{Application 'EPMU1M17' logic file generated by CSPro}
PROC GLOBAL
set explicit;
{ Definitions of working variables }
array alpha(8) KishGrid(10);	   { Grid used for selection of child for child discipline module }
alpha(26) alphavar;				   { Alpha working variable used in checking alpha vars }
alpha(26) alphanew;                { Alpha working variable used in checking alpha vars }
alpha(62) alphalst;                { The alphabet }
array codes(50);                   { Array used for creating line numbers of household members sleeping under mosquito net}
array alpha(50) labels(50);        { Array used for creating names of household members sleeping under mosquito net} 
alpha(40) yname, ynamehh, tmpname; { List of names for questions }
alpha(900) strnotes;               { for editnote at the end of the interview }
alpha(40) worklabel;               { Alpha variable to get customize text for questions }

numeric   hhn,xintnum,xsupnum,xmodcent ;
 
numeric TOTPRIM,maxmain,MOMIN,MOMAX  maxdep;
numeric addmode i cln  hhnum x j ;
string strpart dmois xmois xunite libelle ;

// file FichSaPart ;


// sauvegarde des données 
Function sav()
	savepartial();
end;


// Quitter
Function quitter()
	savepartial();
	stop(1) ;
end;

{ User defined functions }

  function showCalc()
    execsystem("calc");
  end;

  { setup basic user bar }
  function userbase();
    userbar( clear );

    userbar(add text,"ECVM: MOD 17 ");
	userbar(set color,236,254,255);
	
    userbar( add button, "<",    do("PreviousField") );
    userbar( add button, ">",    do("NextField") );
    userbar( add button, ">>|",  do("AdvanceToEnd") );
    userbar( add button, "Note", do("EditNote") );
    userbar( add button, "Lang", do("ChangeLanguage") );
    userbar( add button, "Calc", showCalc );	
    
 	userbar(add spacing,25);   
	userbar(add button,"Sauvegarde", sav());    
	userbar(add spacing,25);
	userbar(add text," ");
	
	userbar(add button,"Quitter", quitter());    
	userbar(add spacing,25);
	userbar(add text," ");
  end;
  
{ --------------------------------------------------------------------------- }
{ valid
  Checks that a variable has a valid value.
  A valid value is less than 96 and not a special value e.g notappl/missing
  Returns: 1 if valid, 0 if not valid                                        }

function valid(xvar);
  valid = (!special(xvar) and xvar < 96)
end;

{ -------------------------------------------------------------------------- }
{ NAtoZero
  Converts notappl (and 99 - for child labour module) values to zero while not changing other values.
  Returns: 0 if input variable is notappl, else returns it unchanged         }
function NAtoZero(xvar);
  if xvar = notappl or xvar=99 then
    xvar = 0
  endif;
  NAtoZero = xvar;
end;


{ clear_labels
Set value labels for certain questions where the response categories can change }
function clear_labels();
	do i = 1 while i <= 50
	  codes(i) = notappl;
	  labels(i) = "";
	enddo;
end;

//Setting a variable value for the currently loaded task
  function setTaskVar(string varName, string varValue)
    //first checking if the variable is already set
    for i in TASKS.TASK_VARIABLES do
      if toupper(strip(varName)) = toupper(strip(TASK_VARNAME(i))) then
	    TASK_VARVAL(i) = varValue;
	    exit;
	  endif;
    enddo;

    //adding a new variable if in case it hasn't been set alerady
    i = 0;
    while i <= maxocc(TASKS.TASK_VARIABLES) do 
      i = i + 1;
	  if length(strip(TASK_VARNAME(i))) = 0 then
	    TASK_VARNAME(i) = strip(varName);
	    TASK_VARVAL(i) = strip(varValue);
	    break;
	  endif;
    enddo;
  end;

  //Getting the variable value using varibale name for the currently loaded task
  function string getTaskVar(string varName)
    do i = 1 while i <= maxocc(TASKS.TASK_VARIABLES)
      if length(strip(TASK_VARNAME(i))) = 0 then
	    break;
	  endif;
      if toupper(strip(varName)) = toupper(strip(TASK_VARNAME(i))) then
	    getTaskVar = strip(TASK_VARVAL(i));
	    break;
  	  endif;
    enddo;
  end;



function endmess();
  { Returns true if response is REVIEW }
  endmess = ({addmode and}
             accept("Fin du questionnaire",
                     "Vérifier du questionnaire",
                     "Nouvelle quête./Questionnaire après") 
                     <> 2);
end;
{FR}
function alphachk(alpha(26) alphamask);
{  russian_convert();}
  { first remove all blanks, and duplicate question marks }
  alphanew = "";
 numeric  qmark = 0;
 numeric  lx = 1  l  a ;
  do l = 1 while l <= length(strip(alphavar))
    if alphavar[l:1] <> " " and (alphavar[l:1] <> "?" or not qmark) then
      alphanew[lx:1] = alphavar[l:1];
      lx = lx + 1;
      if alphavar[l:1] = "?" then
        qmark = 1;
      endif;
    endif;
  enddo;
  { aok = 0 - string is bad, aok = 1 - string is good }
numeric   totlen = length(strip(alphamask));
 numeric  aok = 0;           { assume string is bad - for empty string }
 numeric alphsize = length(strip(alphanew));
  if alphsize then   { not empty string }
    { check for "?" as only character }
    aok = (alphanew[1:1] = "?" and alphsize = 1);
    if !aok then     { if not a single "?", check string }
      aok = 1;       { now assume string is good until we know otherwise }
      l = 1;         { l is position in string of acceptable values }
      a = 1;         { a is position in input string }
      { loop while the string is still good and there are more letters }
      while aok and a <= alphsize do
        aok = pos(alphanew[a:1],alphamask[l:totlen-l+1]);
        if aok then     { letter is acceptable }
          l = l + aok;  { increment l to position after letter in string of acceptable values }
          a = a + 1     { increment a to next letter in input string }
        endif;
      enddo;
    endif;
  endif;
  alphachk = (!aok);    { alphachk = 0 - if string is good, = 1 - if string is bad }
  { now expand variables }
  if aok then
    do l = 1 while l <= length(strip(alphamask))
      if pos(alphamask[l:1],alphanew) then
        alphavar[l:1] = alphamask[l:1]
      elseif pos("?",alphanew) then
        alphavar[l:1] = "?"
      else
        alphavar[l:1] = " "
      endif;
    enddo;
  endif;
end;

{ function to clear codes and labels for household members }
function clean_labels();
	do i = 1 while i <= 30 by 1
	  codes(i)  = notappl;
	  labels(i) = "";
	enddo;
end;

function onStop();
    savepartial();
    stop(-1);
end;



PROC EPMU1M17_FF



preproc
  //Initializing global variables
  SetGlobalVariables();
  tempDir = projectDir + "\Temp";
  utilsDir = projectDir + "\Utils";
  
  setfont(All,"Cambria",30);
  
   setvaluesets("_FRA");  //to set valuesets in French


  //reading the task
  TASK_ID = trimQuotes(readEnviValue("taskId"));
  loadcase(TASKS, TASK_ID);

  //if task is water quality questionnaire task, loading parent household task
  if strip(TASK_TEMPLATENAME) <> "hh_int" & length(strip(TASK_PARENTID)) > 0 then
    TASK_ID = TASK_PARENTID;
    loadcase(TASKS, TASK_ID);
  endif;



  hhnum  = 0;       { last household number used }
 


  cln=tonumber(sysparm()[1:3]);
  hhn=tonumber(sysparm()[4:2]);
  xintnum  = tonumber( sysparm()[9:3] );
  xsupnum  = tonumber( sysparm()[12:3] );


  alphalst = "ABCDEFGHIJKLMNOPQRSTUVWXYZÃÇÅÄÁÆÈÊËÌÍÎÏÐÑÒÓÔÕÖØÙÚÛÝÞßáãäåæíÉìÂ";
 

  { settings for CAPI }

  set attributes (EPMU1M17) assisted on;
  set attributes (EPMU1M17) assisted off (variable (title));

  { set up minimal user bar }
  userbase();
  userbar( show );


postproc
  { update file with households assigned to interviewers }
   //if !xmodcent then
   //  updthhassgn();
   //endif;
  if !xmodcent then      { central office desn't have to exit after reviewing one HH }
    stop(-1);
  endif;
  



PROC M17
preproc
if demode() = add then addmode = 1 endif;
if demode() = modify then addmode = 2 endif;
if demode() = verify then addmode = 3 endif;

  
  if ispartial() then
    advance to getsymbol(savepartial);
  endif;


postproc
endlevel 











PROC M171
preproc
  if special(visualvalue($)) then
    $ = cln;
  endif;

postproc
  YCLUSTER = $;
  if loadcase( CLUSTERS, YCLUSTER ) then
    M177 = YURBRUR;
    M178 = YREGION;
  endif;
PROC M172
preproc
  if hhn <> 0 & (special(visualvalue($)) | visualvalue($) = hhn) then
    $ = hhn;
  endif;

postproc
  set attributes(M17NAME) native;
  if addmode then
    M17NAME = getTaskVar("hhead");
    M17ADDR = getTaskVar("address");
  else
    if length(strip(M17NAME)) then 
      set attributes (M17NAME) protect;
      set attributes (M17ADDR) protect;
    else 
      M17NAME = getTaskVar("hhead");
      M17ADDR = getTaskVar("address");
    endif;
  endif;
PROC M17INT
preproc
  if addmode | special(visualvalue($)) then
    $ = xintnum;
    M17INT = xintnum;
    M17HINT = xsupnum;
  endif;
PROC M173
preproc
  if addmode | special(visualvalue($)) then
   // $ = xintnum;
    $ = 0;
    M17INT = xintnum ;
    M17HINT = xintnum;
  endif;
  
PROC M177
preproc
  if addmode | special(visualvalue($)) then
    M177 = 1;
  endif;
  
PROC M178
preproc

M178 = 10 ;
PROC M17NAME
preproc
  if !addmode then
    exit;
  endif;
PROC M17ADDR
preproc
  if !addmode then
    exit;
  endif;
PROC M1711
postproc
  if $ <> 1 then
    skip to M1717
  endif;  
PROC M176J
preproc
if demode() = add then 
	if special(visualvalue($)) then
	    x = sysdate();
	    if M176J = notappl then M176J = sysdate( "DD" );endif;
	    if M176M = notappl then M176M = sysdate( "MM" );endif;
	    if M176A = notappl then M176A = sysdate( "YYYY" );endif;
	endif;
endif;

postproc
numeric xdate;
xdate = (((visualvalue(M176A)*100)+visualvalue(M176M))*100)+ M176J;
if xdate > sysdate("YYYYMMDD") then 
errmsg("la date saisie est supérieure à la date du jour ,veuillez régler la date de la tablette");
stop(1) ;
endif;

PROC M179H
preproc
if demode() = add then 
  if special(visualvalue($)) then
    x = systime();
    if M179H = notappl then M179H = int(x / 10000);endif;
    if M179M = notappl then M179M = int(x / 100) % 100;endif;
  endif;
endif;
PROC G1
sav()
PROC G2A_A

if G2A_A = 2 then
	skip to G2B_A;
Endif;

PROC G2B_A

if G2B_A = 2 then
	skip to G2C_A;
Endif;
PROC G2C_A

if G2C_A = 2 then
	skip to G2D_A;
Endif;
PROC G2D_A

if G2D_A = 2 then
	skip to G2E_A;
Endif;
PROC G2E_A

if G2E_A = 2 then
	skip to G2F_A;
Endif;
PROC G2F_A

if G2F_A = 2 then
	skip to G2G_A;
Endif;
PROC G2G_A

if G2G_A = 2 then
	skip to G2H_A;
Endif;
PROC G2H_A

if G2H_A = 2 then
	skip to G2I_A;
Endif;
PROC G2I_A

if G2I_A = 2 then
	skip to G3;
Endif;
PROC G7A

If G7A = 2 then
	skip to G7B;
Endif;

PROC G7B

If G7B = 2 then
	skip to G7C;
Endif;
 
sav()
PROC G7C

If G7C = 2 then
	skip to G7D;
Endif;
PROC G7D

If G7D = 2 then
	skip to G7E;
Endif;
PROC G7E

If G7E = 2 then
	skip to G7F;
Endif;
PROC G7F

If G7F = 2 then
	skip to G7G;
Endif;
PROC G7G

If G7G = 2 then
	skip to G7H;
Endif;
PROC G7H

If G7H = 2 then
	skip to G7I;
Endif;
PROC G7I

If G7I = 2 then
	skip to G7J;
Endif;
PROC G7J

If G7J = 2 then
	skip to G7K;
Endif;
PROC G7K

If G7K = 2 then
	skip to G7L;
Endif;
PROC G7L

If G7L = 2 then
	skip to G8;
Endif;
PROC G9

If G9 = 2 then
	skip to G12A;
Endif;


PROC G11

alphavar = $;
  if alphachk("ABCDEFG") then
    errmsg(9998);
    reenter
  else
    $ = alphavar;
    
  endif;

if pos("X",$) then
     editnote();
    if length (strip(editnote()))<5 then
  		errmsg("Le Service Indiquez est non Valide");
    	reenter;
	endif;
	
endif;

PROC G12G

sav()
PROC G16

If $ = 1 then
	skip to G18;
Endif
PROC G17_9

if $ = 1 then

     editnote();
    if length (strip(editnote()))<5 then
  		errmsg("Indiquer votre Raison sur la non participation à la vôre");
    	reenter;
	endif;
endif;
PROC M1710H

preproc
if demode() = add then 
  if special(visualvalue($)) then
    x = systime();
    if M1710H = notappl then M1710H = int(x / 10000);endif;
    if M1710M = notappl then M1710M = int(x / 100) % 100;endif;
  endif;
endif;
PROC M17FIN


preproc
$ = 3;

postproc

if $ = 1 then 
	errmsg(" Vous pouvez remonter ");
	reenter ;
endif;

if $ = 2 then editnote() endif;

$ = 3 ;



