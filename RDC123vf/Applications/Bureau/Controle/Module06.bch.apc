{Application 'MODULE06' logic file generated by CSPro}
PROC GLOBAL


set explicit ;
alpha(26) alphavar;				   { Alpha working variable used in checking alpha vars }
alpha(26) alphanew;                { Alpha working variable used in checking alpha vars }
alpha(62) alphalst;                { The alphabet }
numeric nconsent, nresult, nas, x, y, z, tt, nl, na, nmois, n12dmois, rev, np, nautrmode, nptotal, nc, 
xEA16, xps, xmtotal, k, n, xEA24, xEA24A, xEA24B, xEA25, xEA26, xEA27, xEA28;


string douzedernmois;


function alphachk(alpha(26) alphamask);
{  russian_convert();}
  { first remove all blanks, and duplicate question marks }
  alphanew = "";
 numeric  qmark = 0;
 numeric  lx = 1  l  a ;
  do l = 1 while l <= length(strip(alphavar))
    if alphavar[l:1] <> " " and (alphavar[l:1] <> "?" or not qmark) then
      alphanew[lx:1] = alphavar[l:1];
      lx = lx + 1;
      if alphavar[l:1] = "?" then
        qmark = 1;
      endif;
    endif;
  enddo;
  { aok = 0 - string is bad, aok = 1 - string is good }
numeric   totlen = length(strip(alphamask));
 numeric  aok = 0;           { assume string is bad - for empty string }
 numeric alphsize = length(strip(alphanew));
  if alphsize then   { not empty string }
    { check for "?" as only character }
    aok = (alphanew[1:1] = "?" and alphsize = 1);
    if !aok then     { if not a single "?", check string }
      aok = 1;       { now assume string is good until we know otherwise }
      l = 1;         { l is position in string of acceptable values }
      a = 1;         { a is position in input string }
      { loop while the string is still good and there are more letters }
      while aok and a <= alphsize do
        aok = pos(alphanew[a:1],alphamask[l:totlen-l+1]);
        if aok then     { letter is acceptable }
          l = l + aok;  { increment l to position after letter in string of acceptable values }
          a = a + 1     { increment a to next letter in input string }
        endif;
      enddo;
    endif;
  endif;
  alphachk = (!aok);    { alphachk = 0 - if string is good, = 1 - if string is bad }
  { now expand variables }
  if aok then
    do l = 1 while l <= length(strip(alphamask))
      if pos(alphamask[l:1],alphanew) then
        alphavar[l:1] = alphamask[l:1]
      elseif pos("?",alphanew) then
        alphavar[l:1] = "?"
      else
        alphavar[l:1] = " "
      endif;
    enddo;
  endif;
end;


PROC EPMU1M06_FF


preproc
set behavior() specialvalues(zero) on;

PROC M061

 errmsg("MODULE 6: ENTREPRISES NON AGRICOLE DU MENAGE ");
 errmsg("==============================================");
PROC M0611

nconsent = 0;
nconsent = nconsent + M0611;

x = totocc(ENTREPRISET_EDT) ;

if not invalueset(M0611) and M0611 <> notappl then
	errmsg(110000,M061,M062,M06INT,nconsent);
endif;

if M0611 = 2 then
	if x < 0 then
    	errmsg(117001,M061,M062,M06INT);
    endif;
endif;

if $ <> 1 then
	if x > 0 then
    	errmsg(117002,M061,M062,M06INT,getlabel($,$));
    endif;
endif;  


PROC M0617


nresult = nresult + 0;
nresult = nresult + M0617;

 
if not invalueset(M0617)and M0617 <> notappl then
	errmsg(170000,M061,M062,M06INT,nresult,getlabel($,$));
endif;

if M0611 = 1 and M0617 = NOTAPPL then
	errmsg(171101,M061,M062,M06INT);
endif;
PROC EA01


if not invalueset(EA01)and EA01 <> notappl then
	errmsg(010000,M061,M062,M06INT,EA01);
endif;

if EA01 = 2 and x > 0 then 
  errmsg(017001,M061,M062,M06INT);
endif;
PROC EA0AN

 nl=0 ;
nl = nl + EA0AN ;

y = totocc(ENTREPRISES_EDT);

if EA0AN > 0 then
	if EA0AN <> y and EA0AN >= 0 then
		errmsg(007102,M061,M062,M06INT,nl,y);
	endif;
endif;
PROC EA05


if length (strip($)) < 5 and EA05 <> "" then
	errmsg (050001,M061,M062,M06INT,getlabel($,$));
endif;
PROC EA08C

nas = 0;
nas = nas + EA08C;

if not invalueset(EA08C) and EA08C <> notappl then
	errmsg(080000,M061,M062,M06INT,nas,strip(EA05));
endif;

if EA08C = 2 and EA09A <> "" and EA09B > 0 then 
   errmsg(080901,M061,M062,M06INT,strip(EA05));
endif;
	
PROC EA10A

na = 0;
na = na + EA10A ;

if EA0AN > 0 then
	if not invalueset(EA10A) and EA10A <> notappl then
		errmsg(100000,M061,M062,M06INT,na,strip(EA05));
	endif;
endif;
PROC EA10B

nmois = 0;
nmois = nmois + EA10B;

	if not invalueset(EA10B) and EA10B <> notappl then
		errmsg(100001,M061,M062,M06INT,nmois,strip(EA05));
	endif;
	
	if EA10B = 12 then
		errmsg(100002,M061,M062,M06INT,strip(EA05));
	endif;

	if EA10A > 0 and EA10B <> notappl then
		errmsg(101003,M061,M062,M06INT,EA10A,nmois,strip(EA05));
	endif;
PROC EA11

numeric xlastdate ;

n12dmois = 0;
n12dmois = n12dmois + EA11 ;
	
xlastdate = dateadd( ( ((M066A * 100) + M066M) * 100) + M066J  ,-13,"m");
string sldat =edit("99999999",xlastdate) ;

//sixdernmois = concat( sldat[7:2] ," ", getlabel( M236M,tonumber(sldat[5:2])) , " ", sldat[1:4] ) ; le jour/mois/annee//

douzedernmois = concat( getlabel( M066M,tonumber(sldat[5:2])) , " ", sldat[1:4] ) ;

if not invalueset(EA11)and EA11 <> notappl then
	errmsg(112000,M061,M062,M06INT,n12dmois,strip(EA05),douzedernmois);
endif;
		
if EA10B > 0 and $ > EA10B then
	errmsg(111001,M061,M062,M06INT,douzedernmois,n12dmois,EA10B,strip(EA05));
endif;
PROC EA12

rev = 0;
rev = rev + EA12 ;

if not invalueset(EA12) and EA12 <> notappl then
	errmsg(120000,M061,M062,M06INT,rev,strip(EA05));
endif;
PROC EA13


 np =0 ;
 np =np + EA13 ;
 
if not invalueset(EA13)and EA13 <> notappl then
	errmsg(130000,M061,M062,M06INT,np,strip(EA05));
endif;

if EA12 = 1 and EA13 <> notappl then
	 errmsg(131201,M061,M062,M06INT,strip(EA05),np)
endif;
		
	
if EA12 = 2 and EA13 = 0 then
	errmsg(131202,M061,M062,M06INT,strip(EA05));
endif;
	
if EA12 = 2 and EA13 = 100 then
	errmsg(131203,M061,M062,M06INT,strip(EA05));
endif; 
	
PROC EA15

nc = 0;
nc = nc + EA15 ;

if not invalueset(EA15) and EA15 <> notappl then
	errmsg(150000,M061,M062,M06INT,nc,strip(EA05));
endif;

if EA14 = 1 and EA15 = 1 then errmsg(151401,M061,M062,M06INT,strip(EA05)); endif; 
if EA14 = 1 and EA15 = 2 then errmsg(151402,M061,M062,M06INT,strip(EA05)); endif;
if EA14 = 2 and EA15 = 2 then errmsg(151403,M061,M062,M06INT,strip(EA05)); endif; 
if EA14 = 2 and EA15 = 3 then errmsg(151404,M061,M062,M06INT,strip(EA05)); endif; 
if EA14 = 3 and EA15 = 3 then errmsg(151405,M061,M062,M06INT,strip(EA05)); endif; 
if EA14 = 5 and EA15 = 1 then errmsg(151406,M061,M062,M06INT,strip(EA05)); endif;
if EA14 = 5 and EA15 = 3 then errmsg(151407,M061,M062,M06INT,strip(EA05)); endif;
PROC EA16

xEA16 = 0 ;
xEA16 = xEA16 + EA16 ;

if not invalueset(EA16)and EA16 <> notappl then
	errmsg(160000,M061,M062,M06INT,xEA16,strip(EA05));
endif;
PROC EA17

xps = 0;
xps = xps + EA17;


if not invalueset(EA17)and EA17 <> notappl then
	errmsg(172000,M061,M062,M06INT,xps,strip(EA05));
endif;

if EA16 in 2,3 and EA17 <> notappl then
	errmsg(171601,M061,M062,M06INT,strip(EA05),getlabel($,$));
endif;

PROC EA18


xmtotal = 0 ;
xmtotal = xmtotal + EA18 ;

if EA18 <> notappl then
	
	if EA18 < 500 then
		errmsg(180001,M061,M062,M06INT,xmtotal,strip(EA05));
	endif;
		
	if EA18%50 <> 0 then
		errmsg(180002,M061,M062,M06INT,xmtotal,strip(EA05));
	endif;
		
	if EA16 in 2,3 and EA18 <> notappl then 
		errmsg(181604,M061,M062,M06INT,strip(EA05),xmtotal);
	endif;
		
	if EA17 = 1 and EA18 <> notappl then
		errmsg(181705,M061,M062,M06INT,xmtotal,strip(EA05));
	endif;
	
endif;
PROC EA19

nptotal = 0;
nptotal = nptotal + EA19 ;

	if not invalueset(EA19)and EA19 <> notappl then
		errmsg(190000,M061,M062,M06INT,nptotal,strip(EA05));
	endif;

	if EA16 in 2,3 and EA19 <> notappl then
		errmsg(191601,M061,M062,M06INT,strip(EA05),nptotal);
	endif; 
	
	if EA17 = 1 and EA19 <> notappl then
		errmsg(191702,M061,M062,M06INT,nptotal,strip(EA05));
	endif;

PROC EA19A

nautrmode = 0;
nautrmode = nautrmode + EA19A ;

	if not invalueset(EA19A)and EA19A <> notappl then
		errmsg(192000,M061,M062,M06INT,nautrmode,strip(EA05));
	endif;

	if EA16 in 2,3 and EA19A <> notappl then
		errmsg(191602,M061,M062,M06INT,strip(EA05),getlabel($,$));
	endif;

PROC EA21

k = 0;
k = k + EA21 ;

if not invalueset(EA21)and EA21 <> notappl then
	errmsg(210000,M061,M062,M06INT,k,strip(EA05));
endif;
	
if EA20 = 1 and EA21 = 2 then
	errmsg(212001,M061,M062,M06INT,strip(EA05));
endif;
	
if EA20 = 1 and EA21 = 3 then
	errmsg(212002,M061,M062,M06INT,strip(EA05));
endif;
	
if EA20 = 4 and EA21 = 2 then
	errmsg(212003,M061,M062,M06INT,strip(EA05));
endif;
	
if EA20 = 4 and EA21 = 3 then
	errmsg(212004,M061,M062,M06INT,strip(EA05)); 
endif;
PROC EA22

if not alphachk("ABCX") then
  errmsg(220000,M061,M062,M06INT,strip(EA22),strip(EA05));
endif;  
	
if  pos("X",$) & poschar("ABC",EA22) then
  errmsg(220001,M061,M062,M06INT,strip(EA05));
endif;
	
if EA20 = 4 and  pos("A",EA22) then
	errmsg(222002,M061,M062,M06INT,strip(EA05));
endif ;
	
if EA20 = 4 and pos("B",EA22) then
	 errmsg(222003,M061,M062,M06INT,strip(EA05));
endif ;
PROC EA24

xEA24 = 0;
xEA24 = xEA24 + EA24 ;

if not invalueset(EA24)and EA24 <> notappl then
	errmsg(240000,M061,M062,M06INT,xEA24,strip(EA05));
endif;
PROC EA25


xEA25 = 0;
xEA25 = xEA25 + EA25;

if not invalueset(EA25)and EA25 <> notappl then
	errmsg(250000,M061,M062,M06INT,xEA25,strip(EA05));
endif;
	
if EA25 < 500 then
	errmsg(250000,M061,M062,M06INT,xEA25,strip(EA05));
endif;
	
if EA25%50 <> 0 then
	errmsg(250001,M061,M062,M06INT,xEA25,strip(EA05));
endif;

PROC EA26


xEA26 = 0;
xEA26 = xEA26 + EA26;

if not invalueset(EA26)and EA26 <> notappl then
	errmsg(260000,M061,M062,M06INT,xEA26,strip(EA05));
endif;
PROC EA27

xEA27 = 0;
xEA27 = xEA27 + EA27;

if not invalueset(EA27)and EA27 <> notappl then
	errmsg(270000,M061,M062,M06INT,xEA27,strip(EA05));
endif;
	
if EA26 <> 1 and EA27 <> notappl then
	errmsg(272601,M061,M062,M06INT,getlabel($,$),strip(EA05));
endif;
PROC EA28


xEA28 = 0;
xEA28 = xEA28 + EA28;
	
if EA28 <> notappl then	
	if EA28 < 50 then
		errmsg(280000,M061,M062,M06INT,xEA28,strip(EA05));
	endif;
		
	if EA28%50 <> 0 then
		errmsg(280001,M061,M062,M06INT,xEA28,strip(EA05));
	endif;
endif;
PROC EA24A

EA24A = 0;
xEA24A = xEA24A + EA24A;

if EA24A <> notappl then

	if EA24A < 0 then
		errmsg(240001,M061,M062,M06INT,xEA24A,strip(EA05));
	endif;
	
	if EA24 < EA24A then
		errmsg(240002,M061,M062,M06INT,xEA24A,xEA24,strip(EA05));
	endif;

endif;
PROC EA24B


EA24B = 0;
xEA24B = xEA24B + EA24B;

if EA24B <> notappl then

	if EA24B < 0 then
		errmsg(240003,M061,M062,M06INT,xEA24B);
	endif;
	
	
	if EA24 < EA24B then
		errmsg(240004,M061,M062,M06INT,xEA24B,xEA24,strip(EA05));
	endif;
	
	if EA24A + EA24B <> EA24 then
		errmsg(240005,M061,M062,M06INT,xEA24A,xEA24B,xEA24,strip(EA05));
	endif;

endif;
