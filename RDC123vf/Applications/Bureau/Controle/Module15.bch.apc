{Application 'MODULE15' logic file generated by CSPro}
PROC GLOBAL


//set behavior() specialvalues(zero) on;


set explicit;
{ Definitions of working variables }
array alpha(8) KishGrid(10);	   { Grid used for selection of child for child discipline module }
alpha(26) alphavar;				   { Alpha working variable used in checking alpha vars }
alpha(26) alphanew;                { Alpha working variable used in checking alpha vars }
alpha(62) alphalst;                { The alphabet }
array codes(50);                   { Array used for creating line numbers of household members sleeping under mosquito net}
array alpha(50) labels(50);        { Array used for creating names of household members sleeping under mosquito net} 
alpha(40) yname, ynamehh, tmpname; { List of names for questions }
alpha(900) strnotes;               { for editnote at the end of the interview }
alpha(40) worklabel;               { Alpha variable to get customize text for questions }

numeric   hhn,xintnum,xsupnum,xmodcent ;
 
numeric TOTPRIM,maxmain,MOMIN,MOMAX  maxdep;
numeric addmode i cln  hhnum x j ;
string strpart dmois xmois xunite libelle ;


// sauvegarde des données 
Function sav()
	savepartial();
end;


// Quitter
Function quitter()
	savepartial();
	stop(1) ;
end;

{ User defined functions }

  function showCalc()
    execsystem("calc");
  end;

  { setup basic user bar }
  function userbase();
    userbar( clear );

    
    userbar(add text,"ECVM :MOD 15 ");
	userbar(set color,236,254,255);
	
    userbar( add button, "<",    do("PreviousField") );
    userbar( add button, ">",    do("NextField") );
    userbar( add button, ">>|",  do("AdvanceToEnd") );
    userbar( add button, "Note", do("EditNote") );
    userbar( add button, "Lang", do("ChangeLanguage") );
    userbar( add button, "Calc", showCalc );	
    
 	userbar(add spacing,25);   
	userbar(add button,"Sauvegarde", sav());    
	userbar(add spacing,25);
	userbar(add text," ");
	
	userbar(add button,"Quitter", quitter());    
	userbar(add spacing,25);
	userbar(add text," ");
  end;
  
{ --------------------------------------------------------------------------- }
{ valid
  Checks that a variable has a valid value.
  A valid value is less than 96 and not a special value e.g notappl/missing
  Returns: 1 if valid, 0 if not valid                                        }

function valid(xvar);
  valid = (!special(xvar) and xvar < 96)
end;

{ -------------------------------------------------------------------------- }
{ NAtoZero
  Converts notappl (and 99 - for child labour module) values to zero while not changing other values.
  Returns: 0 if input variable is notappl, else returns it unchanged         }
function NAtoZero(xvar);
  if xvar = notappl or xvar=99 then
    xvar = 0
  endif;
  NAtoZero = xvar;
end;


{ clear_labels
Set value labels for certain questions where the response categories can change }
function clear_labels();
	do i = 1 while i <= 50
	  codes(i) = notappl;
	  labels(i) = "";
	enddo;
end;


function endmess();
  { Returns true if response is REVIEW }
  endmess = ({addmode and}
             accept("Fin du questionnaire",
                     "Vérifier du questionnaire",
                     "Nouvelle quête./Questionnaire après") 
                     <> 2);
end;
{FR}
function alphachk(alpha(26) alphamask);
{  russian_convert();}
  { first remove all blanks, and duplicate question marks }
  alphanew = "";
 numeric  qmark = 0;
 numeric  lx = 1  l  a ;
  do l = 1 while l <= length(strip(alphavar))
    if alphavar[l:1] <> " " and (alphavar[l:1] <> "?" or not qmark) then
      alphanew[lx:1] = alphavar[l:1];
      lx = lx + 1;
      if alphavar[l:1] = "?" then
        qmark = 1;
      endif;
    endif;
  enddo;
  { aok = 0 - string is bad, aok = 1 - string is good }
numeric   totlen = length(strip(alphamask));
 numeric  aok = 0;           { assume string is bad - for empty string }
 numeric alphsize = length(strip(alphanew));
  if alphsize then   { not empty string }
    { check for "?" as only character }
    aok = (alphanew[1:1] = "?" and alphsize = 1);
    if !aok then     { if not a single "?", check string }
      aok = 1;       { now assume string is good until we know otherwise }
      l = 1;         { l is position in string of acceptable values }
      a = 1;         { a is position in input string }
      { loop while the string is still good and there are more letters }
      while aok and a <= alphsize do
        aok = pos(alphanew[a:1],alphamask[l:totlen-l+1]);
        if aok then     { letter is acceptable }
          l = l + aok;  { increment l to position after letter in string of acceptable values }
          a = a + 1     { increment a to next letter in input string }
        endif;
      enddo;
    endif;
  endif;
  alphachk = (!aok);    { alphachk = 0 - if string is good, = 1 - if string is bad }
  { now expand variables }
  if aok then
    do l = 1 while l <= length(strip(alphamask))
      if pos(alphamask[l:1],alphanew) then
        alphavar[l:1] = alphamask[l:1]
      elseif pos("?",alphanew) then
        alphavar[l:1] = "?"
      else
        alphavar[l:1] = " "
      endif;
    enddo;
  endif;
end;

{ function to clear codes and labels for household members }
function clean_labels();
	do i = 1 while i <= 30 by 1
	  codes(i)  = notappl;
	  labels(i) = "";
	enddo;
end;

function onStop();
    savepartial();
    stop(-1);
end;




PROC EPMU1M15_FF
preproc
set behavior() specialvalues(zero) on;

PROC M151

 errmsg("ERREURS MODULE 15 : EPARGNE ET CREDIT )");
 errmsg("======================================)");
PROC M1511
x = totocc(MOD15_EDT) ;

if not invalueset(M1511) then
	errmsg(110000,M151,M152,M15INT,15,M1511, "Consentement");
endif;

if $ <> 1 then
    if x > 0 then
    	errmsg(117001,M151,M152,M15INT,15,getlabel($,$));
   endif;
endif;
PROC NBR_18

if NBR_18 = 0 and totocc(MOD15_EDT)> 0 then
  errmsg(187001,M151,M152,M15INT,15) ;
endif;
PROC EC0
onfocus
		if i = 0 then
				errmsg(000001,M151,M152,M15INT,15);
				Reenter $;
		endif;
				
setvalueset(@getsymbol(),codes,labels);
setcapturetype($,3);

postproc

do varying j=1 while j <=1 

 if codes(j) = EC0 then
 	EC0B = strip(labels(j));
 endif;

enddo
PROC EC1
numeric xEC1=0;
xEC1=xEC1+EC1;

if not invalueset(EC1)and $ <> notappl  then
	errmsg(010000,M151,M152,M15INT,15,xEC1,"EC1");
endif;

//if EC1(curocc())=1 and special( visualvalue(EC2(curocc()))) then
//errmsg("incomptatibilité car une valeur invalide");
//endif;
PROC EC2_A

if not invalueset(EC2_A) and EC1<>2 then
	errmsg(020000,M151,M152,M15INT,15,EC2_A, "EC2_A");
endif;


if invalueset(EC2_A) and EC1=1 and $ <> notappl  then
	errmsg(020102,M151,M152,M15INT,15);
endif;

PROC EC2_B

if not invalueset(EC2_B) and EC1<>2 then
	errmsg(020000,M151,M152,M15INT,15,EC2_B, "EC2_B");
endif;


if invalueset(EC2_B) and EC1=1 and $ <> notappl  then
	errmsg(020102,M151,M152,M15INT,15);
endif;

PROC EC2_C

if not invalueset(EC2_C)  and EC1<>2 then
	errmsg(020000,M151,M152,M15INT,15,EC2_C, "EC2_C");
endif;


if invalueset(EC2_C) and EC1=1 and $ <> notappl  then
	errmsg(020102,M151,M152,M15INT,15);
endif;

PROC EC2_D

if not invalueset(EC2_D) and EC1<>2 then
	errmsg(020000,M151,M152,M15INT,15,EC2_D, "EC2_D");
endif;


if invalueset(EC2_D) and EC1=1 and $ <> notappl  then
	errmsg(020102,M151,M152,M15INT,15);
endif;

PROC EC2_E

if not invalueset(EC2_E)  and EC1<>2 then
	errmsg(020000,M151,M152,M15INT,15,EC2_E, "EC2_E");
endif;


if invalueset(EC2_E) and EC1=1 and $ <> notappl  then
	errmsg(020102,M151,M152,M15INT,15);
endif;

PROC EC2_F

if not invalueset(EC2_F)  and EC1<>2 then
	errmsg(020000,M151,M152,M15INT,15,EC2_F, "EC2_F");
endif;


if invalueset(EC2_F) and EC1=1 and $ <> notappl  then
	errmsg(020102,M151,M152,M15INT,15);
endif;

PROC EC2_G


if not invalueset(EC2_G) and EC1<>2 then
	errmsg(020000,M151,M152,M15INT,15,EC2_G, "EC2_G");
endif;


if invalueset(EC2_G) and EC1=1 and $ <> notappl  then
	errmsg(020102,M151,M152,M15INT,15);
endif;




if EC2_A=2 and EC2_B=2 and EC2_C=2 and EC2_D=2 and EC2_E=2 and EC2_F=2 and EC2_G=2 and   EC1=1 then
	errmsg(020101,M151,M152,M15INT,15);
endif;

PROC EC3
numeric xEC3=0;
xEC3=xEC3+EC3;

if not invalueset(EC3)  and EC1<>2 then
	errmsg(030000,M151,M152,M15INT,15,xEC3,"EC3");
endif;

if EC2_A=2 and EC2_B=2 and EC2_C=2 and EC2_D=2 and EC2_E=2 and EC2_F=2 and EC2_G=2 and EC3=1 then
errmsg(030101,M151,M152,M15INT,15);
endif;


if invalueset(EC3) and EC1=2 then 
	errmsg(030102,M151,M152,M15INT,15);
endif;
PROC EC4
numeric xEC4=0;
xEC4=xEC4+EC4;
if not invalueset(EC4) and $ <> notappl  then
	errmsg(040000,M151,M152,M15INT,15,xEC4,"EC4");
endif;
PROC EC5
numeric xEC5=0;
xEC5=xEC5+EC5;
if not invalueset(EC5) and $ <> notappl  then
	errmsg(050000,M151,M152,M15INT,15,xEC5,"EC5");
endif;

 
PROC EC6
numeric xEC6=0;
xEC6=xEC6+EC6;

if not invalueset(EC6) and EC1<>2 then
	errmsg(060000,M151,M152,M15INT,15,xEC6,"EC6");
endif;

if $=7 then 
   editnote();
       if length(strip(editnote()))<10 then
	     errmsg(060001,M151,M152,M15INT,15);
       endif;
endif;


if EC5=1 and EC6 <> notappl then 
errmsg(060002,M151,M152,M15INT,15);
endif;
PROC EC7
numeric xEC7=0;
xEC7=xEC7+EC7;

if not invalueset(EC7) and $ <> notappl  then
	errmsg(070000,M151,M152,M15INT,15,xEC7,"EC7");
endif;
PROC EC8
numeric xEC8=0;
xEC8=xEC8+EC8;

if not invalueset(EC8)  and EC1<>2 then
	errmsg(080000,M151,M152,M15INT,15,xEC8,"EC8");
endif;

if $=5 then 
	editnote();
	   if length(strip(editnote()))< 10 then
			errmsg(080001,M151,M152,M15INT,15);
	   endif;
endif;

if EC7 = 1 and  EC8 <> notappl  then
	errmsg(080002,M151,M152,M15INT,15);
endif;

if EC7 = 2 and  EC8 = notappl  then
	errmsg(080003,M151,M152,M15INT,15);
endif;
PROC EC9
numeric xEC9=0;
xEC9=xEC9+EC9;

if not invalueset(EC9)  and EC1<>2 then
	errmsg(090000,M151,M152,M15INT,15,xEC9,"EC9");
endif;


if EC7 = 1 and  EC9 <> notappl  then
	errmsg(090001,M151,M152,M15INT,15);
endif;

if EC7 = 2 and  EC9 = notappl  then
	errmsg(090002,M151,M152,M15INT,15);
endif;
PROC EC11
numeric xEC11=0;
xEC11=xEC11+EC11;
if not invalueset(EC11) and $ <> notappl  then
	errmsg(110000,M151,M152,M15INT,15,xEC11,"EC11");
endif;
PROC EC12
numeric xEC12=0;
xEC12=xEC12+EC12;

if not invalueset(EC12) then
	errmsg(120000,M151,M152,M15INT,15,xEC12,"EC12");
endif;

if $=9 then
  editnote();
     if length(strip(editnote()))< 10 then
	    errmsg(120001,M151,M152,M15INT,15);
     endif;
endif;
 
PROC EC13
numeric xEC13=0;
xEC13=xEC13+EC13;
if not invalueset(EC13) and $ <> notappl  then
	errmsg(130000,M151,M152,M15INT,15,xEC13,"EC13");
endif;


PROC EC14M
postproc

if EC14A=2018 and ( M156M < EC14M )then
 errmsg(140001,M151,M152,M15INT,15,EC14M);
 reenter;
endif;

  
PROC EC15

if $ <1000 then
 errmsg(150001,M151,M152,M15INT,15);
endif;
PROC EC16
numeric xEC16=0;
xEC16=xEC16+EC16;
if not invalueset(EC16) and $ <> notappl  then
	errmsg(160000,M151,M152,M15INT,15,xEC16,"EC16");
endif;
PROC EC18

if EC18  < 100 then
	 errmsg(180001,M151,M152,M15INT,15);
endif;
if EC18 > EC15 then
	errmsg(180002,M151,M152,M15INT,15);
endif;
