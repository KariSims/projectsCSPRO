{Application 'INTERVIEWERMENU' logic file generated by CSPro}
PROC GLOBAL

  //folders
  string RepApp, RepDict, entryDir, dataDir, refDir, tasksDir, syncDir, intervDir, delegDir, workDir, backupDir;
  string btAddress, InterviewerId, InterviewerName, SupervisorId;  
  string intTaskFile, encrKey;
  numeric IntGender;
  
  array string teamIdIndex(9999); //index of interviwer team by ID
  array teamIds(50);              //array of team IDs
  numeric teamMemberCount;        //total number of team members
  
  numeric debugMode;              //1 - debug mode, 0 - non-debug mode
  numeric removableOnly;          //1 - backup to removable drive only, 0 - scan all accessable drives
  
  numeric splitMin, splitMax;     //minimum and maximum numbers that can be assigned to split households
  numeric splitInterval;          //Maximum number of household to be split by one interviewer in a cluster
  
  file f1;
  
  array string caseIds(10, 2);    //array that is used by deleteCase function to identify case IDs
  array string taskIds(99);       //used to store task IDs of tasks before deletion
  
  //Setting a variable value for the currently loaded task
  function setTaskVar(string varName, string varValue)
    numeric i;
    //first checking if the variable is already set
    for i in TASKS.TASK_VARIABLES do
      if toupper(strip(varName)) = toupper(strip(TASK_VARNAME(i))) then
	    TASK_VARVAL(i) = varValue;
	  	    exit;
	  endif;

    enddo;

// ajoutant une nouvelle variable si, dans le cas où elle n'a pas été configurée
    i = 0;
    while i <= maxocc(TASKS.TASK_VARIABLES) do 
      i = i + 1;
	  if length(strip(TASK_VARNAME(i))) = 0 then
	    TASK_VARNAME(i) = strip(varName);
	    TASK_VARVAL(i) = strip(varValue);
	    break;
	  endif;
    enddo;
  end;

// Obtient la valeur de la variable en utilisant le nom de la variable pour la tâche actuellement chargée
  function string getTaskVar(string varName)
    numeric i;
    do i = 1 while i <= maxocc(TASKS.TASK_VARIABLES)
      if length(strip(TASK_VARNAME(i))) = 0 then
	    break;
	  endif;
      if toupper(strip(varName)) = toupper(strip(TASK_VARNAME(i))) then
	    getTaskVar = strip(TASK_VARVAL(i));
	    break;
  	  endif;
    enddo;
  end;
  
// cette fonction va  créer le répertoire s'il n'existe pas déjà
  function string setDir(string dir)
    if !direxist(dir) then
      dircreate(dir);
    endif;
    setDir = dir;
  end;
  

function  Sauvegarde() ;
string xSD = "ABCDEFGHIJKLMNOPQRTSUVWXY",   SDdir  ;
numeric p = 1 , T= 0  ;
 
 
       // Sauvegarde des données dans la tablette
       
        if !dirExist(backupDir + "\Data") then  dircreate(backupDir + "\Data"); endif;
        if !dirExist(backupDir + "\Delegated") then  dircreate(backupDir + "\Delegated"); endif;
        if !dirExist(backupDir + "\Tasks") then  dircreate(backupDir + "\Tasks"); endif;
        
        filecopy(dataDir + "\?" + edit("999", MCLUST) + "*", backupDir + "\Data" );
        filecopy(delegDir + "\?" + edit("999", MCLUST) + "*", backupDir + "\Delegated");
        filecopy(tasksDir + "\T" + edit("99999", MCLUST) + "*", backupDir + "\Tasks");


	do varying p=1 until p>=25  ;
     
    if fileexist(xSD[p:1] + ":\SavPauv\Enq.txt") then
     SDdir = xSD[p:1]+":\SavPauv" ;

       // Dossier de saugvergade des données avant suppression
        if !dirExist(SDdir + "\Data") then  dircreate(SDdir + "\Data"); endif;
        if !dirExist(SDdir + "\Delegated") then  dircreate(SDdir + "\Delegated"); endif;
        if !dirExist(SDdir + "\Tasks") then  dircreate(SDdir + "\Tasks"); endif;
        
        filecopy(dataDir + "\?" + edit("999", MCLUST) + "*", SDdir + "\Data" );
        filecopy(delegDir + "\?" + edit("999", MCLUST) + "*", SDdir + "\Delegated");
        filecopy(tasksDir + "\T" + edit("99999", MCLUST) + "*", SDdir + "\Tasks");
    	
    endif ;
    
  enddo;
end;


function SavCSD()
string xSD = "ABCDEFGHIJKLMNOPQRTSUVWXY",   SDdir  ;
numeric p = 1 , T= 0  ;

       // Sauvegarde des données dans la tablette
       
 SDdir = backupDir + "\SavPauv\SupData" + edit("9999999999",int(publishdate()/10000 ));       
       
        if !dirExist(SDdir) then
          dircreate(SDdir + "\Data");
          dircreate(SDdir + "\Delegated");
          dircreate(SDdir + "\Tasks");
        endif;
        
        filecopy(dataDir + "\?" + edit("999", MCLUST) + "*", SDdir + "\Data" );
        filecopy(delegDir + "\?" + edit("999", MCLUST) + "*", SDdir + "\Delegated");
        filecopy(tasksDir + "\T" + edit("99999", MCLUST) + "*", SDdir + "\Tasks");


  // Sauvegarde dans les unités
	do varying p=1 until p>=25  ;
	 
    if fileexist(xSD[p:1] + ":\SavPauv\Enq.txt") then

     SDdir = xSD[p:1] +":\SavPauv\SupData" + edit("9999999999",int(publishdate()/10000 ));
     
       // Dossier de saugvergade des données avant suppression
        if !dirExist(SDdir) then
          dircreate(SDdir + "\Data");
          dircreate(SDdir + "\Delegated");
          dircreate(SDdir + "\Tasks");
        endif;
        
        filecopy(dataDir + "\?" + edit("999", MCLUST) + "*", SDdir + "\Data" );
        filecopy(delegDir + "\?" + edit("999", MCLUST) + "*", SDdir + "\Delegated");
        filecopy(tasksDir + "\T" + edit("99999", MCLUST) + "*", SDdir + "\Tasks");

    endif ;
    
  enddo;
end;


// sauvegarde des données pour le cluster actuel vers un lecteur amovible
  function backupData(sauver)
   // sauvegarde des données avant suppression 
   Sauvegarde() ;
   if sauver=2 then  SavCSD() ;    endif ;
   
  end;
    
// construire des tableaux d'équipe
  function fillTeam()
    numeric curNum = UNUMBER;
    numeric curTeam = UTEAM;
    string curId = UID;
    
    close(USERS_DICT);
    open(USERS_DICT);
    
    teamMemberCount = 0;
    while loadcase(USERS_DICT) do
      if UTEAM = curTeam then
        teamMemberCount = teamMemberCount + 1;
        teamIds(teamMemberCount) = UNUMBER;
        teamIdIndex(UNUMBER) = UID;

        execEnvi(maketext("int ig_%d = %d;", UNUMBER, UGENDER)); // configuration de l'intervieweur sexe variables ENVI utilisées pour la délégation de filtrage
        
        if UROLE = 2 then 
          SupervisorId = edit("99999", UNUMBER);
        endif;
      endif;
    enddo;

    close(USERS_DICT);
    
  // trier la liste des membres de l'équipe (nécessaire car CSPro trie les cas par identification du cas, qui est l'adresse MAC Bluetooth)
    numeric i, j, k;
    do i = 1 while i < teamMemberCount by 1
      do j = i + 1 while j <= teamMemberCount by 1
        if teamIds(j) < teamIds(i) then
          k = teamIds(i);
          teamIds(i) = teamIds(j);
          teamIds(j) = k;
        endif;
      enddo;
    enddo;

    
// recharger l'enregistrement d'utilisateur original
    UID = curId;
    loadcase(USERS_DICT, UID);
    
  end;
  
// affiche les tâches courantes de l'intervieweur
  function showTasks()
    numeric res = 0;

    // tâches de chargement
    loadTasks("intTasks", 0, RepDict + "\tasks.dcf", intTaskFile);
          
    // montrant des tâches
    showTaskList("intTasks");
  
		// résultat de lecture
     // la fonction renvoie l'ID de l'option. Tâche chargée dans un dictionnaire TASKS
    string ares;
    if fileexist(tempDir + "\taskList.tmp") then
      setfile(f1, tempDir + "\taskList.tmp");
      open(f1);  
      fileread(f1, ares);
      close(f1);
      
      split(ares, ";");
            
     // dossier de chargement
      filedelete(intTaskFile + ".idx");
      setfile(TASKS, intTaskFile);
      open(TASKS);
      TASK_ID = strip(spl(1));
      if loadcase(TASKS, TASK_ID) then
        res = tonumber(spl(2));
      endif;
      close(TASKS);
    endif;
    showTasks = res;
  end;
  
  function concatHhData()
    string xFileNum = edit("999", MCLUST);
    filedelete(tempDir + "\allhh.dat");
    filedelete(tempDir + "\allhh.dat.idx");
    fileconcat(tempDir + "\allhh.dat", dataDir + "\H" + xFileNum + "???.dat", delegDir + "\H" + xFileNum + "???.dat");
  end;
  
  // met à jour l'état des tâches en fonction des données du cluster
  function updateTasks()
    concatHhData();
  
    string taskFile = tasksDir + "\T" + edit("99999", MCLUST) + edit("99999", tonumber(InterviewerId)) + "_HhAssigned.dat";
    
    // suppression du fichier index
    filedelete(taskFile + ".idx");
  
    string xFileNum = edit("999", MCLUST) + edit("999", tonumber(interviewerId));

    // écrit le pff
    openPffFile(tempDir + "\updateTasks.pff", 2);
    
    writePff_InputFiles(intervDir + "\UpdateTasks.bch",
                        tempDir + "\allhh.dat",
                        tempDir + "\UpdateTasks.lst",
                        tempDir + "\UpdateTasks.wrt");
                                                                                // NAB
    writePff_ExternalFile("EPMU1M01", dataDir + "\8" + xFileNum + ".dat");
    writePff_ExternalFile("EPMU1M19", dataDir + "\A" + xFileNum + ".dat");  
    writePff_ExternalFile("EPMU1M16", dataDir + "\B" + xFileNum + ".dat");
    writePff_ExternalFile("EPMU1M20", dataDir + "\C" + xFileNum + ".dat");
    writePff_ExternalFile("EPMU1M08", dataDir + "\D" + xFileNum + ".dat");
    writePff_ExternalFile("EPMU1M07", dataDir + "\E" + xFileNum + ".dat");
    writePff_ExternalFile("EPMU1M21", dataDir + "\F" + xFileNum + ".dat");
    writePff_ExternalFile("EPMU1M22", dataDir + "\G" + xFileNum + ".dat");
    writePff_ExternalFile("EPMU1M23", dataDir + "\I" + xFileNum + ".dat");
    writePff_ExternalFile("EPMU1M24", dataDir + "\J" + xFileNum + ".dat");
    writePff_ExternalFile("EPMU1M26", dataDir + "\K" + xFileNum + ".dat");
    writePff_ExternalFile("EPMU1M14", dataDir + "\L" + xFileNum + ".dat");
    writePff_ExternalFile("EPMU1M12", dataDir + "\M" + xFileNum + ".dat");
    writePff_ExternalFile("EPMU1M27", dataDir + "\N" + xFileNum + ".dat");
    writePff_ExternalFile("EPMU1M28", dataDir + "\O" + xFileNum + ".dat");
    writePff_ExternalFile("EPMU1M29", dataDir + "\P" + xFileNum + ".dat");
    writePff_ExternalFile("EPMU1M13", dataDir + "\Q" + xFileNum + ".dat");
    writePff_ExternalFile("EPMU1M18", dataDir + "\R" + xFileNum + ".dat");
    writePff_ExternalFile("EPMU1M11", dataDir + "\S" + xFileNum + ".dat");   
    writePff_ExternalFile("EPMU1M30", dataDir + "\U" + xFileNum + ".dat");
    writePff_ExternalFile("EPMU1M31", dataDir + "\V" + xFileNum + ".dat");
    writePff_ExternalFile("EPMU1M32", dataDir + "\W" + xFileNum + ".dat");
    writePff_ExternalFile("EPMU1M15", dataDir + "\X" + xFileNum + ".dat");
    writePff_ExternalFile("EPMU1M09", dataDir + "\Y" + xFileNum + ".dat");
    writePff_ExternalFile("EPMU1M17", dataDir + "\Z" + xFileNum + ".dat");
    writePff_ExternalFile("EPMU1M33", dataDir + "\1" + xFileNum + ".dat");
    writePff_ExternalFile("EPMU1M06", dataDir + "\2" + xFileNum + ".dat");
    writePff_ExternalFile("EPMU1M34", dataDir + "\3" + xFileNum + ".dat");
    writePff_ExternalFile("EPMU1M10", dataDir + "\4" + xFileNum + ".dat");
    writePff_ExternalFile("EPMU1M35", dataDir + "\5" + xFileNum + ".dat");
    writePff_ExternalFile("EPMU1M25", dataDir + "\6" + xFileNum + ".dat");
    writePff_ExternalFile("EPMU1M37", dataDir + "\7" + xFileNum + ".dat");

    
    writePff_ExternalFile("TASKS", taskFile);

    closePffFile(0, "");
    
   // exécution de l'application UpdateTasks
    runBatch(tempDir + "\updateTasks.pff");
    
   // nettoyer le fichier de tâches (ignorer les tâches supprimées)
    cleanupTaskFile2(taskFile, length(TASK_ID), 1);
    
    // tri par numéro de ligne
    sortTasks(taskFile, RepDict + "\tasks.dcf", "lnnum");
    
    // suppression des paquets de synchronisation redondants
    string s;
    string shelf = "outgoing";
    if fileexist(tempDir + "\UpdateTasks.wrt") then
      close(f1);
      setfile(f1, tempDir + "\UpdateTasks.wrt");
      open(f1);
      
      while fileread(f1, s) do
        if split(s, ";") > 1 then
          removeFromSync("Deleg" + spl(1), edit("99999", tonumber(spl(2))), edit("99999", tonumber(InterviewerId)), shelf);
        endif;
      enddo;
      
      close(f1);
    endif;
  end;

  // crée un package de synchronisation pour le superviseur
  // Si la même machine, copie les fichiers dans le dossier "travail"
  function packDataForSup()
    string shelf = "outgoing";
    string xFileNum = edit("999", MCLUST) + edit("999", tonumber(interviewerId));
    string qTypes = "HABCDEFGIJKLMNOPQRSUVWXYZ12345678";  // NAB
    string sFile, dFile;
    numeric i, j;
    if tonumber(interviewerId) = tonumber(supervisorId) then
      do i = 1 while i <= length(qTypes) by 1
        filedelete(maketext("%s\%s%s.dat.idx", workDir, qTypes[i:1], xFileNum));
        filecopy(maketext("%s\%s%s.dat", dataDir, qTypes[i:1], xFileNum), maketext("%s\%s%s.dat", workDir, qTypes[i:1], xFileNum));
        filecopy(maketext("%s\%s%s.dat.not", dataDir, qTypes[i:1], xFileNum), maketext("%s\%s%s.dat.not", workDir, qTypes[i:1], xFileNum));
        filecopy(maketext("%s\%s%s.dat.sts", dataDir, qTypes[i:1], xFileNum), maketext("%s\%s%s.dat.sts", workDir, qTypes[i:1], xFileNum));
      enddo;
    else
      // création de la variable ENVI pour les fichiers à synchroniser avec le superviseur
      string ee = "fileslist fl;";
      do i = 1 while i <= length(qTypes) by 1
        do j = 1 while j <= 3 by 1
          if j = 1 then
            sFile = maketext("%s\%s%s.dat", dataDir, qTypes[i:1], xFileNum);
            dFile = maketext("%s\%s%s.dat", workDir, qTypes[i:1], xFileNum);
          elseif j = 2 then
            sFile = maketext("%s\%s%s.dat.not", dataDir, qTypes[i:1], xFileNum);
            dFile = maketext("%s\%s%s.dat.not", workDir, qTypes[i:1], xFileNum);
          else
            sFile = maketext("%s\%s%s.dat.sts", dataDir, qTypes[i:1], xFileNum);
            dFile = maketext("%s\%s%s.dat.sts", workDir, qTypes[i:1], xFileNum);
          endif;
          if fileexist(sFile) then           
            ee = ee + "filerec fr;";
            ee = ee + maketext("fr.source = '%s';", sFile);
            ee = ee + maketext("fr.dest += '%s';", dFile);
            ee = ee + "fl.files += fr;";
          endif;
        enddo;
      enddo;
      execenvi(ee);
      
      string contentId = "DataForSup" + xFileNum; // ID du contenu du paquet
      
      // suppression de l'ancien paquet si présent
      removeFromSync(contentId, edit("99999", tonumber(SupervisorId)), edit("99999", tonumber(InterviewerId)), shelf);
      
      // création d'un nouveau paquet
      addFilesToSync("fl", contentId, edit("99999", tonumber(SupervisorId)), edit("99999", tonumber(InterviewerId)), encrKey, shelf);
    endif;
  end;


  function genHhIntPff(revisit, modCompl, partial, hw, noPart)
 
      //Continuer un questionnaire    genHhIntPff(0, 0, 1, 0, 0); 
      //revisiter un questionnaire    genHhIntPff(0, 1, 0, 0, 0); 

   filedelete(tempDir + "\SaisieHH.pff");

   openPffFile(tempDir + "\SaisieHH.pff", 1);
    
    numeric hhNum = toNumber(getTaskVar("hhnum"));
    string hhId = edit("999", MCLUST) + edit("99", hhNum) + edit("999", tonumber(interviewerId)) + "00";
    string xFileNum = edit("999", MCLUST) + edit("999", tonumber(interviewerId));
    
   // string xloc = "MOFIFY,VERIFY" ;
    string mode = "ADD";
    
   { if revisit | modCompl | partial  then
      mode = "MODIFY";
      xloc = "ADD,VERIFY"
    endif;
    }
    
    writePff_DataEntryInit("EPMU1", "Verify", mode + ";" + hhId, 1, 1);
       
    string app = entryDir + "\SaisieHH.ent";
    
    writePff_InputFiles(app,
                        dataDir + "\H" + xFileNum + ".dat",
                        dataDir + "\H" + xFileNum + ".lst", "");
                        
    writePff_ExternalFile("CLUSTERS", refDir + "\clusters.dat");
    writePff_ExternalFile("TASKS", tasksDir + "\T" + edit("99999", MCLUST) + edit("99999", tonumber(InterviewerId)) + "_HhAssigned.dat");
    
    string p1 = edit("999", MCLUST) + 
                edit("99", hhNum) +
                "   " +
                edit("999", tonumber(interviewerId)) +
                edit("999", tonumber(supervisorId)) +
                "0" +
                "0" +                  //Modify by central office
                edit("9", revisit) +   //Revisit
                edit("9", modCompl) +  //Modify completed
                edit("9", partial) +   //Partial
                edit("9", hw) +        //
                
                edit("9", noPart);     //partial save flag
    
    closePffFile(0, p1);
    
    execEnvi("string taskId = '" + TASK_ID + "';");
    
    runEntry(tempDir + "\SaisieHH.pff");
    
    packDataForSup(); //Paquets des données du superviseur 
    backupData(1);   //Sauvergarde des données
  end;
  
  
  function deleteHousehold()
  
  // faire une sauvegarde des données avant la suppression
    backupData(2); //Backing up data

   // suppression de données (ménage et individus)
    string dc, df;
    numeric i;
   
     do i = 1 while i <= 33 by 1
				     
				 if i = 1 then // Module Ménage							
				        df = dataDir + "\H" + edit("999", MCLUST) + edit("999", tonumber(InterviewerId)) + ".*";									
				 elseif i = 2	then	// Module 19					
				        df = dataDir + "\A" + edit("999", MCLUST) + edit("999", tonumber(InterviewerId)) + ".*";							
				 elseif i = 3	then	// Module 16					
				        df = dataDir + "\B" + edit("999", MCLUST) + edit("999", tonumber(InterviewerId)) + ".*";							
				 elseif i = 4	then	// Module 20					
				        df = dataDir + "\C" + edit("999", MCLUST) + edit("999", tonumber(InterviewerId)) + ".*";		               		 			
				 elseif i = 5	then	// Module 08					
				        df = dataDir + "\D" + edit("999", MCLUST) + edit("999", tonumber(InterviewerId)) + ".*";		 					
				 elseif i = 6	then	// Module 07					
				        df = dataDir + "\E" + edit("999", MCLUST) + edit("999", tonumber(InterviewerId)) + ".*";							
				 elseif i = 7	then	// Module 21					
				        df = dataDir + "\F" + edit("999", MCLUST) + edit("999", tonumber(InterviewerId)) + ".*";			 				
				 elseif i = 8	then	// Module 22					
				        df = dataDir + "\G" + edit("999", MCLUST) + edit("999", tonumber(InterviewerId)) + ".*";		 					
				 elseif i = 9	then	// Module 23					
				        df = dataDir + "\I" + edit("999", MCLUST) + edit("999", tonumber(InterviewerId)) + ".*";			 				
				 elseif i = 10	then	// Module 24					
				        df = dataDir + "\J" + edit("999", MCLUST) + edit("999", tonumber(InterviewerId)) + ".*";			 				
				 elseif i = 11	then	// Module 26					
				        df = dataDir + "\K" + edit("999", MCLUST) + edit("999", tonumber(InterviewerId)) + ".*";				 			
				 elseif i = 12	then	// Module 14					
				        df = dataDir + "\L" + edit("999", MCLUST) + edit("999", tonumber(InterviewerId)) + ".*";			 				
				 elseif i = 13	then	// Module 12					
				        df = dataDir + "\M" + edit("999", MCLUST) + edit("999", tonumber(InterviewerId)) + ".*";				 			
				 elseif i = 14	then	// Module 27					
				        df = dataDir + "\N" + edit("999", MCLUST) + edit("999", tonumber(InterviewerId)) + ".*";				 			
				 elseif i = 15	then	// Module 28					
				        df = dataDir + "\O" + edit("999", MCLUST) + edit("999", tonumber(InterviewerId)) + ".*";				 			
				 elseif i = 16	then	// Module 29					
				        df = dataDir + "\P" + edit("999", MCLUST) + edit("999", tonumber(InterviewerId)) + ".*";					 		
				 elseif i = 17	then	// Module 13					
				        df = dataDir + "\Q" + edit("999", MCLUST) + edit("999", tonumber(InterviewerId)) + ".*";			 				
				 elseif i = 18	then	// Module 18					
				        df = dataDir + "\R" + edit("999", MCLUST) + edit("999", tonumber(InterviewerId)) + ".*";				 			
				 elseif i = 19	then	// Module 11					
				        df = dataDir + "\S" + edit("999", MCLUST) + edit("999", tonumber(InterviewerId)) + ".*";		 					
				 elseif i = 20	then	// Module 30					
				        df = dataDir + "\U" + edit("999", MCLUST) + edit("999", tonumber(InterviewerId)) + ".*";			 				
				 elseif i = 21	then	// Module 31					
				        df = dataDir + "\V" + edit("999", MCLUST) + edit("999", tonumber(InterviewerId)) + ".*";		 					
				 elseif i = 22	then	// Module 32					
				        df = dataDir + "\W" + edit("999", MCLUST) + edit("999", tonumber(InterviewerId)) + ".*";				 			
				 elseif i = 23	then	// Module 15					
				        df = dataDir + "\X" + edit("999", MCLUST) + edit("999", tonumber(InterviewerId)) + ".*";				 			
				 elseif i = 24	then	// Module 09					
				        df = dataDir + "\Y" + edit("999", MCLUST) + edit("999", tonumber(InterviewerId)) + ".*";				 			
				 elseif i = 25	then	// Module 17					
				        df = dataDir + "\Z" + edit("999", MCLUST) + edit("999", tonumber(InterviewerId)) + ".*";				 			
				 elseif i = 26	then	// Module 33					
				        df = dataDir + "\1" + edit("999", MCLUST) + edit("999", tonumber(InterviewerId)) + ".*";				 			
				 elseif i = 27	then	// Module 06					
				        df = dataDir + "\2" + edit("999", MCLUST) + edit("999", tonumber(InterviewerId)) + ".*";			 				
				 elseif i = 28	then	// Module 34					
				        df = dataDir + "\3" + edit("999", MCLUST) + edit("999", tonumber(InterviewerId)) + ".*";				 			
				 elseif i = 29	then	// Module 10 		
				        df = dataDir + "\4" + edit("999", MCLUST) + edit("999", tonumber(InterviewerId)) + ".*";				 			
				 elseif i = 30	then	// Module 35					
				        df = dataDir + "\5" + edit("999", MCLUST) + edit("999", tonumber(InterviewerId)) + ".*";				 			
				 elseif i = 31	then	// Module 25					
				        df = dataDir + "\6" + edit("999", MCLUST) + edit("999", tonumber(InterviewerId)) + ".*";				 			
				 elseif i = 32	then	// Module 37					
				        df = dataDir + "\7" + edit("999", MCLUST) + edit("999", tonumber(InterviewerId)) + ".*";							
				        			 				
				 elseif i = 33	then	// Module 01					
				        df = dataDir + "\8" + edit("999", MCLUST) + edit("999", tonumber(InterviewerId)) + ".*";		    					
				        							
				    filedelete(df);
				    
				endif;    

    enddo;
  
    packDataForSup(); //packaging data for supervisor
  //  backupData(); //Backing up data
  end;
  
   // génère un nouveau numéro de ménage pour le ménage fractionné
   // renvoie 0 si l'on ne peut pas générer un nouveau numéro HH
  function getSplitHhNum()
    numeric i, res = 0, r;
    string ot;
   // obtenir l'index de l'intervieweur dans une équipe
    do i = 1 while i <= teamMemberCount by 1
      if teamIds(i) = tonumber(interviewerId) then
        res = i;
        break;
      endif;
    enddo;
    
    if res > 0 then
      res = splitMin + splitInterval * (res - 1);
      r = res;
      
      ot = TASK_ID;
      
      // trouver un endroit vide pour le nouveau numéro de ménage
      close(TASKS);
      open(TASKS);
      
      while loadcase(TASKS) do
        if strip(TASK_TEMPLATENAME) = "hh_int" then
          i = tonumber(getTaskVar("hhnum"));
          if !special(i) and i >= res then
            res = i + 1;
          endif;
        endif;
      enddo;
      
      close(TASKS);
      
      //reloading original task
      TASK_ID = ot;
      loadcase(TASKS, TASK_ID);
    endif;
    
    //checking if not over the limit
    if res >= r + splitInterval then
      res = 0;
    endif;
    
    getSplitHhNum = res;
  end;

  function splitHousehold()
    numeric oldHhNum = tonumber(getTaskVar("hhnum"));
    numeric newHhNum = getSplitHhNum();
    
    if !newHhNum then
      errmsg(11);
      exit;
    endif;
    
    string hhAddr = getTaskVar("address");
    string hhead = getTaskVar("hhead");
    
    //updating existing household task vars
    setTaskVar("issplit", "true");
    setTaskVar("childhh", maketext("%d", newHhNum));
    writecase(TASKS, TASK_ID);
    
    //creating new household task
    clear(TASKS);
    TASK_ID = GetGuid();
    TASK_TEMPLATENAME = "hh_int";
    TASK_LABEL = "Interview ménage #<%d:hhnum,2:00%><br>Addresse: <%address%><br> Nom du chef de ménage : <%hhead%>"; //!T
    
    TASK_STATUS = 1;
    TASK_PARENTID = "";
            
    setTaskVar("hhnum", edit("99999", newHhNum));
    setTaskVar("address", hhAddr);
    setTaskVar("hhead", hhead);
    setTaskVar("intnum", edit("99999", tonumber(InterviewerId)));
    setTaskVar("intname", InterviewerName);
    setTaskVar("issplit", "true");
    setTaskVar("parenthh", maketext("%d", oldHhNum));
            
    TASK_DUMMY = 0;
            
    writecase(TASKS, TASK_ID);
    
    close(TASKS);
    
    errmsg(12, oldHhNum, newHhNum);
  end;

  function acceptHousehold()
    TASK_STATUS = 2;
    writecase(TASKS, TASK_ID);

    string tId = TASK_ID;
            
    close(TASKS);
    open(TASKS);
    //settre le statut de la tache du module à 1
    while loadcase(TASKS) do
      if strip(TASK_PARENTID) = tId then
        TASK_STATUS = 1;
        writecase(TASKS, TASK_ID);
      endif;
    enddo;
    
    TASK_ID = tId;
    loadcase(TASKS, TASK_ID);
    close(TASKS);
  end;


// A regarder selon le template 

  //handles household interviews
  function hh_int(optionId)
    if optionId = 1 then          //start unvisited household
     // function genHhIntPff(revisit, modCompl, partial, hw, noPart)
      genHhIntPff(0, 0, 0, 0, 0);
      
     elseif optionId = 2 then      //Continuer un questionnaire   genHhIntPff(0, 0, 1, 0, 0); 
      //genHhIntPff(0, 0, 1, 0, 0); 
      genHhIntPff(0, 1, 0, 0, 0); 
      
    elseif optionId = 3 then      //revisiter un questionnaire  genHhIntPff(0, 1, 0, 0, 0); 
     // genHhIntPff(0, 1, 0, 0, 0); 
        genHhIntPff(0, 0, 1, 0, 0); 
        
    elseif optionId = 4 then      //Supprimer le ménage
   numeric  Err = errmsg("Confirmez-vous la suppression du ménage ? ") select("Oui ",continue, "Non ",continue);
     if err=1 then deleteHousehold(); endif ;
    endif ;
       
  end;
  
  
  // PFF DES MODULES
  function genModPff(string qts, continuer, modifier, Drapeau,string pcar)
  
    openPffFile(tempDir + "\SaisieModule.pff", 1);
    
    numeric hhNum = toNumber(getTaskVar("hhnum"));
    numeric lnNum = toNumber(getTaskVar("lnnum"));
    string indId = edit("999", MCLUST) + edit("99", hhNum) + edit("999", tonumber(interviewerId)) +  "00";
    string xFileNum = edit("999", MCLUST) + edit("999", tonumber(interviewerId));
 				     
		filewrite(pffTemp, "[DataEntryInit]");
		filewrite(pffTemp, "OperatorID=" + "EPMU1");
		
		
	//	    if continuer = 1 or modifier=1 then
	//			filewrite(pffTemp, "StartMode=" + "MODIFY"+ ";" + indId );
	//			filewrite(pffTemp, "Lock=ADD, Verify");			
	//	    else
				filewrite(pffTemp, "StartMode=" + "ADD"+ ";" + indId );
				filewrite(pffTemp, "Lock=Modify, Verify");	
	//	    endif;		
		
		
		//filewrite(pffTemp, "StartMode=" + "ADD" + ";" + indId );
		//filewrite(pffTemp, "Lock=Verify");	
			
		filewrite(pffTemp, "Fullscreen=Nomenus") ;
		filewrite(pffTemp, "NoFileOpen=Yes");

   
    string app = entryDir + "\EPMU1" + qts + ".ent";
    
    writePff_InputFiles(app,
                        dataDir + "\" + pcar + xFileNum + ".dat",
                        dataDir + "\" + pcar + xFileNum + ".lst", "");

    writePff_ExternalFile("EPMU1", tempDir + "\allhh.dat");
    writePff_ExternalFile("TASKS", tasksDir + "\T" + edit("99999", MCLUST) + edit("99999", tonumber(InterviewerId)) + "_HhAssigned.dat");
    
    string p1 = edit("999", MCLUST) + 
                edit("99", hhNum) +
                edit("99", lnNum) +
                " " +
                edit("999", tonumber(interviewerId)) +
                "0000" +
                "0" +                  //Modificatier au bureau central
                edit("9", Continuer) + //Revisiter
                edit("9", modifier) +  //Modification d'un module complet 
                edit("9", drapeau);    //partial save flag
    
 
//   closePffFile(0, p1);
    

  filewrite(pffTemp, "[Parameters]");
  if length(strip(p1)) > 0 then
    filewrite(pffTemp, concat("Parameter=", strip(p1)));
  endif;
  
  filewrite(pffTemp, "ViewListing=Never");
  filewrite(pffTemp, "ViewResults=No");
  
  filewrite(pffTemp, "ListingWidth=80");
  filewrite(pffTemp, "MessageWrap=No");
  filewrite(pffTemp, "ErrmsgOverride=No");

 close(pffTemp);
 
    execEnvi("string taskId = '" + TASK_ID + "';");
    
    runEntry(tempDir + "\SaisieModule.pff");
    
    packDataForSup(); //Packaging data for supervisor
    backupData(1) ;
   //Sauvegarde(); //Backing up data
  end;




  //Returns the name of the interviewer by MAC address
  function string getUName(string userId)
    string res = "";
    string oId = UID;
    
    UID = userId;
    if loadcase(USERS_DICT, UID) then
      res = UNAME;
    endif;
    
    //reloading original user
    UID = oId;
    loadcase(USERS_DICT, UID);
    
    getUName = strip(res);
  end;
    
  //delegate current individual task to another interviewers
  function delegate(intNumber)    
    string tId = TASK_ID;
    string ptId = TASK_PARENTID;
    string shelf = "outgoing";
    
    //creating ENVI variable for the task to be synced to the interviewer
    string ee = "task ti1;"                        //declaring t1 ENVI variable of type "task"
    ee = ee + "ti1.id='" + strip(TASK_ID) + "';";  //generated task ID is the same as the household assignment task ID
    ee = ee + "ti1.templatename='" + strip(TASK_TEMPLATENAME) + "';";        //template name for the HH interview is hh_int
    ee = ee + "ti1.label='" + strip(TASK_LABEL) + "';";
    ee = ee + "ti1.status=1;";                     //status set to 1 - not visited
    ee = ee + "ti1.parentid='" + strip(TASK_PARENTID) + "';";                  //hh interview tasks are at the root, not parent
      
    //setting variables
    ee = ee + "var v1;";
    numeric i;
    do i = 1 while i <= maxocc(TASKS.TASK_VARIABLES) by 1
      if length(strip(TASK_VARNAME(i))) > 0 then
        ee = ee + "v1.name='" + strip(TASK_VARNAME(i)) + "';";
        ee = ee + "v1.val='" + strip(TASK_VARVAL(i)) + "';";
        ee = ee + "ti1.variables += v1;";
      endif;
    enddo;
    
    //marking task as delegated
    ee = ee + "v1.name='isdeleg';";
    ee = ee + "v1.val='true';";
    ee = ee + "ti1.variables += v1;";
    
    execenvi(ee);
    
    //creating ENVI variable for the household task
    TASK_ID = ptId;
    loadcase(TASKS, TASK_ID);
    
    ee = "task th1;";
    ee = ee + "th1.id='" + strip(TASK_ID) + "';";  //generated task ID is the same as the household assignment task ID
    ee = ee + "th1.templatename='" + strip(TASK_TEMPLATENAME) + "';";        //template name for the HH interview is hh_int
    ee = ee + "th1.label='" + strip(TASK_LABEL) + "';";
    ee = ee + "th1.status=5;";                     //status set to 1 - not visited
    ee = ee + "th1.parentid='';";                  //hh interview tasks are at the root, not parent

    do i = 1 while i <= maxocc(TASKS.TASK_VARIABLES) by 1
      if length(strip(TASK_VARNAME(i))) > 0 then
        ee = ee + "v1.name='" + strip(TASK_VARNAME(i)) + "';";
        ee = ee + "v1.val='" + strip(TASK_VARVAL(i)) + "';";
        ee = ee + "th1.variables += v1;";
      endif;
    enddo;
        
    execenvi(ee);
    
    //packing tasks (content ID is individual task ID)
    string destFile = tasksDir + "\T" + edit("99999", MCLUST) + edit("99999", intNumber) + "_HhAssigned.dat";
    addTaskToSync("th1", "Deleg" + tId, edit("99999", intNumber), edit("99999", tonumber(InterviewerId)), destFile, shelf);
    addTaskToSync("ti1", "Deleg" + tId, edit("99999", intNumber), edit("99999", tonumber(InterviewerId)), destFile, shelf);
    
    //packing HH data
    string xFileNum = edit("999", MCLUST) + edit("999", tonumber(interviewerId));
    string sFile = maketext("%s\H%s.dat", dataDir, xFileNum);
    string dFile = maketext("%s\H%s.dat", delegDir, xFileNum);
    
    ee = "fileslist fl;";
    ee = ee + "filerec fr;";
    ee = ee + makeText("fr.source = '%s';", sFile);
    ee = ee + makeText("fr.dest += '%s';", dFile);
    ee = ee + "fl.files += fr;";
      
    execenvi(ee);
           
    //packing household data file
    addFilesToSync("fl", "Deleg" + tId, edit("99999", intNumber), edit("99999", tonumber(InterviewerId)), encrKey, shelf);
    
    //marking task as "Delegated"
    //adding interviewer number and name task variables
    TASK_ID = tId;
    loadcase(TASKS, TASK_ID);
    setTaskVar("delintnum", edit("999", intNumber));
    setTaskVar("delintname", getUName(teamIdIndex(intNumber)));
    TASK_STATUS = 2; // = 5
    writecase(TASKS, TASK_ID);      
    close(TASKS);
  end;
  
  //undelegates current individual task
  function undelegate()
    //getting receiver ID
    string receiverId = getTaskVar("delintnum");
    
    string shelf = "outgoing";
    
    //supprimer les packages après synchronisation
    numeric x1 = removeFromSync("Deleg" + TASK_ID, edit("99999", tonumber(receiverId)), edit("99999", tonumber(InterviewerId)), shelf);
    
    //Si la synchronisation ne s'est pas bien déroulée 
    if x1 < 0 then
      errmsg(9903);
      exit;
    endif;
    
    numeric doRemove = 1;
    //La tache est en cours de synchronisation avec l'enqueteur
    if x1 = 0 then
      x1 = errmsg(1003) select("Yes", continue, "No", continue);
      box x1 => doRemove;
          1  => 1;
             => 0;
      endbox;
    endif;
    
    //changing status back to "unassigned"
    if doRemove then
      TASK_STATUS = 1;
      writecase(TASKS, TASK_ID);
      close(TASKS);
    endif;
  end;
  
  //Suppression des questionnaires modules
  function deleteIndividual(string Modul, string  pcar )  // AJOUT NAB
    string df;
    
        // sauvegarde des données avant toute suppression
        
			backupData(2); //Backing up data
			    
		//préaparation des données du module à supprimer 
			if  strip(Modul) = 'M19'  then // Module 19
			        df = dataDir + "\A" + edit("999", MCLUST) + edit("999", tonumber(InterviewerId)) + ".*";	 	
			endif ;  
			if  strip(Modul) = 'M16'  then // Module 16
			        df = dataDir + "\B" + edit("999", MCLUST) + edit("999", tonumber(InterviewerId)) + ".*";	 	
			endif ;  
			if  strip(Modul) = 'M20'  then // Module 20
			        df = dataDir + "\C" + edit("999", MCLUST) + edit("999", tonumber(InterviewerId)) + ".*";	 	
			endif ;  
			if  strip(Modul) = 'M08'  then // Module 08
			        df = dataDir + "\D" + edit("999", MCLUST) + edit("999", tonumber(InterviewerId)) + ".*";	 	
			endif ;  
			if  strip(Modul) = 'M07'  then // Module 07
			        df = dataDir + "\E" + edit("999", MCLUST) + edit("999", tonumber(InterviewerId)) + ".*";	 	
			endif ;  
			if  strip(Modul) = 'M21'  then // Module 21
			        df = dataDir + "\F" + edit("999", MCLUST) + edit("999", tonumber(InterviewerId)) + ".*";	 	
			endif ;  
			if  strip(Modul) = 'M22'  then // Module 22	
			        df = dataDir + "\G" + edit("999", MCLUST) + edit("999", tonumber(InterviewerId)) + ".*";	 	
			endif ;  
			if  strip(Modul) = 'M23'  then // Module 23	
			        df = dataDir + "\I" + edit("999", MCLUST) + edit("999", tonumber(InterviewerId)) + ".*";	 	
			endif ;  
			if  strip(Modul) = 'M24'  then // Module 24	
			        df = dataDir + "\J" + edit("999", MCLUST) + edit("999", tonumber(InterviewerId)) + ".*";	 	
			endif ;  
			if  strip(Modul) = 'M26'  then // Module 26	
			        df = dataDir + "\K" + edit("999", MCLUST) + edit("999", tonumber(InterviewerId)) + ".*";	 	
			endif ;  
			if  strip(Modul) = 'M14'  then // Module 14	
			        df = dataDir + "\L" + edit("999", MCLUST) + edit("999", tonumber(InterviewerId)) + ".*";	 	
			endif ;  
			if  strip(Modul) = 'M12'  then // Module 12	
			        df = dataDir + "\M" + edit("999", MCLUST) + edit("999", tonumber(InterviewerId)) + ".*";	 	
			endif ; 
			 if  strip(Modul) = 'M27'  then // Module 27	
			        df = dataDir + "\N" + edit("999", MCLUST) + edit("999", tonumber(InterviewerId)) + ".*";	 	
			endif ;  
			if  strip(Modul) = 'M28'  then // Module 28	
			        df = dataDir + "\O" + edit("999", MCLUST) + edit("999", tonumber(InterviewerId)) + ".*";	 	
			endif ; 
			 if  strip(Modul) = 'M29'  then // Module 29	
			        df = dataDir + "\P" + edit("999", MCLUST) + edit("999", tonumber(InterviewerId)) + ".*";	 	
			endif ; 
			 if  strip(Modul) = 'M13'  then // Module 13	
			        df = dataDir + "\Q" + edit("999", MCLUST) + edit("999", tonumber(InterviewerId)) + ".*";	 	
			endif ;  
			if  strip(Modul) = 'M18'  then // Module 18	
			        df = dataDir + "\R" + edit("999", MCLUST) + edit("999", tonumber(InterviewerId)) + ".*";	 	
			endif ;  
			if  strip(Modul) = 'M11'  then // Module 11	
			        df = dataDir + "\S" + edit("999", MCLUST) + edit("999", tonumber(InterviewerId)) + ".*";	 	
			endif ;  
			if  strip(Modul) = 'M30'  then // Module 30
			        df = dataDir + "\U" + edit("999", MCLUST) + edit("999", tonumber(InterviewerId)) + ".*";	 	
			endif ; 
			 if  strip(Modul) = 'M31'  then // Module 31
			        df = dataDir + "\V" + edit("999", MCLUST) + edit("999", tonumber(InterviewerId)) + ".*";	 	
			endif ;  
			if  strip(Modul) = 'M32'  then // Module 32
			        df = dataDir + "\W" + edit("999", MCLUST) + edit("999", tonumber(InterviewerId)) + ".*";	 	
			endif ; 
			if  strip(Modul) = 'M15'  then // Module 15
			        df = dataDir + "\X" + edit("999", MCLUST) + edit("999", tonumber(InterviewerId)) + ".*";	 	
			endif ;  
			if  strip(Modul) = 'M09'  then // Module 09	
			        df = dataDir + "\Y" + edit("999", MCLUST) + edit("999", tonumber(InterviewerId)) + ".*";	 	
			endif ;  
			if  strip(Modul) = 'M17'  then // Module 17	
			        df = dataDir + "\Z" + edit("999", MCLUST) + edit("999", tonumber(InterviewerId)) + ".*";	 	
			endif ;  
			if  strip(Modul) = 'M33'  then // Module 33
			        df = dataDir + "\1" + edit("999", MCLUST) + edit("999", tonumber(InterviewerId)) + ".*";	 	
			endif ;  
			if  strip(Modul) = 'M06'  then // Module 06	
			        df = dataDir + "\2" + edit("999", MCLUST) + edit("999", tonumber(InterviewerId)) + ".*";	 	
			endif ;  
			if  strip(Modul) = 'M34'  then // Module 34	
			        df = dataDir + "\3" + edit("999", MCLUST) + edit("999", tonumber(InterviewerId)) + ".*";	 	
			endif ;  
			if  strip(Modul) = 'M10'  then // Module 10   
			        df = dataDir + "\4" + edit("999", MCLUST) + edit("999", tonumber(InterviewerId)) + ".*";	 	
			endif ;  
			if  strip(Modul) = 'M35'  then // Module 35
			        df = dataDir + "\5" + edit("999", MCLUST) + edit("999", tonumber(InterviewerId)) + ".*";	 	
			endif ;  
			if  strip(Modul) = 'M25'  then // Module 25	
			        df = dataDir + "\6" + edit("999", MCLUST) + edit("999", tonumber(InterviewerId)) + ".*";	 	
			endif ;  
			if  strip(Modul) = 'M37'  then // Module 37
			        df = dataDir + "\7" + edit("999", MCLUST) + edit("999", tonumber(InterviewerId)) + ".*";	 		
			endif ;  
			if  strip(Modul) = 'M01'  then // Module 01
			        df = dataDir + "\8" + edit("999", MCLUST) + edit("999", tonumber(InterviewerId)) + ".*";	 	
			endif ;	
			
			filedelete(df) ;

//    NAB
    
    //Mise à jour des taches
    //si le module a été délégué , supprimer sa tache, sinon changer san statut à 1 ;
    if getTaskVar("isdeleg") = "true" then
      string pId = TASK_PARENTID;
      
      delcase(TASKS, TASK_ID);
      
      //vérifier s'il n'y a pas de modules dans le ménage dans ces conditions supprimer les taches du menage 
      numeric iCount = 0;
      close(TASKS);
      open(TASKS);
      while loadcase(TASKS) do
        if TASK_PARENTID = pId then
          iCount = 1;
          break;
        endif;
      enddo;  
      close(TASKS);
      
      if !iCount then
        TASK_ID = pId;
        delcase(TASKS, TASK_ID);
      endif;
    else
      TASK_STATUS = 1;
      writecase(TASKS, TASK_ID);
      close(TASKS);
    endif;
    
    close(TASKS);

    packDataForSup(); //Packaging du chef d'équipe
    backupData(1)
    //Sauvegarde(); //Sauvegarde des données

end;

// A modifier selon le template Module

  function ind_int(optionId, string sQt, string pcar)
  
    concatHhData();
    
     if optionId in 5,11,17,23,29,35,241,47,53,59,65,71,77,83,89,95,101,107,113,119,125,131,137,143,149,155,161,167,173,179,185,191	  then	 //,,Commencer
      genModPff(sQt, 0, 0, 0,pcar); 
    elseif optionId in 6,12,18,24,30,36,242,48,54,60,66,72,78,84,90,96,102,108,114,120,126,132,138,144,150,156,162,168,174,180,186,192	then //,,Continuer
      genModPff(sQt, 1, 0, 0,pcar);    
    elseif optionId in 3,7,13,19,25,31,37,243,49,55,61,67,73,79,85,91,97,103,109,115,121,127,133,139,145,151,157,163,169,175,181,187,193 then //,,Revisiter
        genModPff(sQt, 0, 1, 0,pcar);  
    elseif optionId in 8,14,20,26,32,38,244,50,56,62,68,74,80,86,92,98,104,110,116,122,128,134,140,146,152,158,164,170,176,182,188,194	then //,,Supprimer
       deleteIndividual(sQt, pcar);   
    elseif optionId in 9,15,21,27,33,39,245,51,57,63,69,75,81,87,93,99,105,111,117,123,129,135,141,147,153,159,165,171,177,183,189,195	 then //,,Deleguer
 		  delegate(optionId);   
    elseif optionId in 10,16,22,28,34,40,246,52,58,64,70,76,82,88,94,100,106,112,118,124,130,136,142,148,154,160,166,172,178,184,190,196  then  //,,Supp le delagation
      undelegate();
    endif ;     
    
  end;
  
  
  //main function that makes decisions on routing code execution for currently loaded task  
  function taskRouter(optionId)

   if strip(TASK_TEMPLATENAME) = "hh_int" then  hh_int(optionId);
   
    elseif strip(TASK_TEMPLATENAME) = "mod01_int" then  ind_int(optionId , "M01" , "8");
    elseif strip(TASK_TEMPLATENAME) = "mod19_int" then  ind_int(optionId , "M19" , "A");
    elseif strip(TASK_TEMPLATENAME) = "mod16_int" then  ind_int(optionId , "M16" , "B");
    elseif strip(TASK_TEMPLATENAME) = "mod20_int" then  ind_int(optionId , "M20" , "C");
    elseif strip(TASK_TEMPLATENAME) = "mod08_int" then  ind_int(optionId , "M08" , "D");
    elseif strip(TASK_TEMPLATENAME) = "mod07_int" then  ind_int(optionId , "M07" , "E");
    elseif strip(TASK_TEMPLATENAME) = "mod21_int" then  ind_int(optionId , "M21" , "F");
    elseif strip(TASK_TEMPLATENAME) = "mod22_int" then  ind_int(optionId , "M22" , "G");
    elseif strip(TASK_TEMPLATENAME) = "mod23_int" then  ind_int(optionId , "M23" , "I");
    elseif strip(TASK_TEMPLATENAME) = "mod24_int" then  ind_int(optionId , "M24" , "J");
    elseif strip(TASK_TEMPLATENAME) = "mod26_int" then  ind_int(optionId , "M26" , "K");
    elseif strip(TASK_TEMPLATENAME) = "mod14_int" then  ind_int(optionId , "M14" , "L");
    elseif strip(TASK_TEMPLATENAME) = "mod12_int" then  ind_int(optionId , "M12" , "M");
    elseif strip(TASK_TEMPLATENAME) = "mod27_int" then  ind_int(optionId , "M27" , "N");
    elseif strip(TASK_TEMPLATENAME) = "mod28_int" then  ind_int(optionId , "M28" , "O");
    elseif strip(TASK_TEMPLATENAME) = "mod29_int" then  ind_int(optionId , "M29" , "P");
    elseif strip(TASK_TEMPLATENAME) = "mod13_int" then  ind_int(optionId , "M13" , "Q");
    elseif strip(TASK_TEMPLATENAME) = "mod18_int" then  ind_int(optionId , "M18" , "R");
    elseif strip(TASK_TEMPLATENAME) = "mod11_int" then  ind_int(optionId , "M11" , "S");
    elseif strip(TASK_TEMPLATENAME) = "mod30_int" then  ind_int(optionId , "M30" , "U");
    elseif strip(TASK_TEMPLATENAME) = "mod31_int" then  ind_int(optionId , "M31" , "V");
    elseif strip(TASK_TEMPLATENAME) = "mod32_int" then  ind_int(optionId , "M32" , "W");
    elseif strip(TASK_TEMPLATENAME) = "mod15_int" then  ind_int(optionId , "M15" , "X");
    elseif strip(TASK_TEMPLATENAME) = "mod09_int" then  ind_int(optionId , "M09" , "Y");
    elseif strip(TASK_TEMPLATENAME) = "mod17_int" then  ind_int(optionId , "M17" , "Z");
    elseif strip(TASK_TEMPLATENAME) = "mod33_int" then  ind_int(optionId , "M33" , "1");
    elseif strip(TASK_TEMPLATENAME) = "mod06_int" then  ind_int(optionId , "M06" , "2");
    elseif strip(TASK_TEMPLATENAME) = "mod34_int" then  ind_int(optionId , "M34" , "3");
    elseif strip(TASK_TEMPLATENAME) = "mod10_int" then  ind_int(optionId , "M10" , "4");
    elseif strip(TASK_TEMPLATENAME) = "mod35_int" then  ind_int(optionId , "M35" , "5");
    elseif strip(TASK_TEMPLATENAME) = "mod25_int" then  ind_int(optionId , "M25" , "6");
    elseif strip(TASK_TEMPLATENAME) = "mod37_int" then  ind_int(optionId , "M37" , "7");


    endif;    
    
  end;

// NAB

  //Demarrer la procédure de synchronisation 
  function btSync(remoteId)
    //getting remote peer information
    UID = teamIdIndex(remoteId);
    if loadcase(USERS_DICT, UID) then
      string peerId = edit("ZZZZ9", UNUMBER);
      string peerName = strip(UNAME);
      string peerAddress = strip(UID);

      //construction du filtre de sortie
      string filter = "1:" + edit("99999", UNUMBER) + ";;2:" + edit("99999", tonumber(InterviewerId));
      
      startSync(btAddress, interviewerId, interviewerName, peerAddress, peerId, peerName, RepDict + "\tasks.dcf", filter);
    endif;
  end;

  //Dynamically setting colors for menu options based on synchronization status
  function setMenuColors(syncButtonIndex)
    //setting Sync button color
    numeric c = getOutgoingPackageCount("");
    if c then
      menuOptions(syncButtonIndex) = "2:textcolor=red;;;Synchronisation*";
    else
      menuOptions(syncButtonIndex) = "2:Synchronisation";
    endif;
    
    numeric i, j = syncButtonIndex + 1;
    numeric on;
    string filter;
    //looping through team members
    do i = 1 while i <= teamMemberCount by 1
       UID = teamIdIndex(teamIds(i));
       if loadcase(USERS_DICT, UID) then
         if teamIds(i) <> tonumber(InterviewerId) then //excluding current interviewer
           filter = "1:" + edit("99999", UNUMBER) + ";;2:" + edit("99999", tonumber(InterviewerId));
           c = getOutgoingPackageCount(filter);
           on = UNUMBER + 10000;
           if c then
             menuOptions(j) = maketext(".%d:textcolor=red;;;%d %s*", on, UNUMBER, strip(UNAME));
           else
             menuOptions(j) = maketext(".%d:%d %s", on, UNUMBER, strip(UNAME));
           endif;
           j = j + 1;
         endif;
       endif;
    enddo;
    
    //reloading current interviwer
    UID = btAddress;
    loadcase(USERS_DICT, btAddress);
  end;
  
  function checkUpdates()
    if !fileexist(tempdir + "\update.flag") then
      exit;
    endif;
    
    errmsg(1301);
    
    filedelete(tempdir + "\update.flag");
    
    //Redemarrer le système  
    setfile(f1, tempdir + "\restart.bat", create);
    filedelete(f1);
    open(f1);
    filewrite(f1, "");
    filewrite(f1, "timeout 3 > NUL");
    filewrite(f1, 'start "" "%s\run.lnk"', intervDir);
    close(f1);
    execsystem(tempdir + "\restart.bat", normal, nowait);
    
    exitEnvironment();
    stop(-1);    
  end;


function  VerifSDEnq() ;
   string xSD = "ABCDEFGHIJKLMNOPQRTSUVWXY",   SDdir  ;
   numeric p = 1 , cle= 0  ;
 
   // Sauvegarde incrémentale dans la clé 
   do varying p=1 until p>=25  ;     
	if fileexist(xSD[p:1] + ":\SavPauv\Enq.txt") then
	   cle = 1 ;    	
	endif ;
    enddo;
    
	if cle = 0 then	 
		errmsg("LA CARTE SD N'EST PAS INSTALLEE ! ");  
	endif ;
		   
end;


  
PROC MENU_FF
preproc


  setfont(All,"Cambria",30);

  //Initialisation globale des variables
  SetGlobalVariables();

  //Setting folders
  RepApp = projectDir + "\Applications";        //!!
  RepDict = RepApp + "\Dicts";                 //!!
  entryDir = RepApp + "\Entry";                 //!!
  intervDir = RepApp + "\Interviewer";          //!!
  dataDir = setDir(projectDir + "\Data");       //!!
  refDir = projectDir + "\Reference";           //!!
  tasksDir = setDir(projectDir + "\Tasks");     //!!
  syncDir = setDir(projectDir + "\Sync");       //!!
  delegDir = setDir(projectDir + "\Delegated"); //!!
  workDir = setDir(projectDir + "\Work");       //!!
  
  tempDir = setDir(projectDir + "\Temp");       //!!
  utilsDir = projectDir + "\Utils";             //!!
  backupDir = setDir(projectDir + "\DataBackup");  
  //backupDir = "DataBackup";               //!! backup drive letter is automatically detected based on the presence of a backup directory
  removableOnly = 1;                      //!! default backup scans for removable drives only (set to 0 to include all accessable drives)

  encrKey = "X73R5W6FP7CQAY9H";           //!!encryption key

  debugMode = 0;                          //!! Set to 1 to enable debug mode
  
  splitMin = 30;                          //!! Minimum generated household number of a split household (set to be greater than number of selected HH in cluster)
  splitMax = 99;                          //!! Maximum generated househodl number of a split household
  splitInterval = 10;                     //!! Maximum number of split household per interviewer per cluster

  if debugMode then
    enableDebugMode(tempDir + "\debug.txt");
    writeDebugMessage("Démarrage de la session enqueteur");
  endif;

  set behavior() exit on;
  
  //Getting User information from the BT MAC address
  btAddress = GetBtAddress();
  if !length(btAddress) then
    errmsg(0001);
    exitEnvironment();
    stop(-1);
  else
    UID = btAddress;
    if !loadcase(USERS_DICT, btAddress) then
      InterviewerId = "0";
      InterviewerName = "Utilisateur Inconnu";
      IntGender = 9;
      errmsg(0002, btAddress);
      exitEnvironment();
      stop(-1);
    else
      InterviewerId = edit("ZZZZ9", UNUMBER);
      InterviewerName = strip(UNAME);
      IntGender = UGENDER;
    endif;
  endif;
  
  setTempFolder(tempDir); //informing container app about our temp folder
  
  fillTeam(); //filling in team index arrays

  //creating task list
  createTaskList("intTasks", refDir + "\InterviewerTempl.xml", tempDir + "\tOutput.tmp");  

  //setting cache file for bluetooth synchronization
  setCache(syncDir + "\cache.sqlite");
  
  //Reading state array
  loadPreviousValues();
  
  //Setting interviewer gender ENVI variable (used in task dynamic options)
  execenvi(maketext("int intGender = %d;", IntGender));

  //setting constraints on the menu  
  setMenuConstraints(40, 0, 0, 0);
  
  




PROC MCLUST
onfocus
  if special(visualvalue($)) & state(1) <> 0 then
    $ = state(1);
  endif;

postproc

  // Vérifier l'existence de la SD
  VerifSDEnq() ; 


// Vérification si le cluster existe dans l'échantillon
  YCLUSTER = MCLUST;
  if !loadcase(CLUSTERS, YCLUSTER) then
    errmsg(0010, MCLUST);
    reenter;
  endif;
  
  intTaskFile = tasksDir + "\T" + edit("99999", YCLUSTER) + edit("99999", tonumber(InterviewerId)) + "_HhAssigned.dat";
  
// configuration des contraintes du menu
  setMenuConstraints(40, -1, -1, -1);
  
// construire des options de menu  
  clearMenu();
  addMenuOption("1:Tâches");                            
  numeric syncIdx = addMenuOption("2:Synchronisation");


// ajout des membres de l'équipe 
  string optionsStr = "{";
  string rSex = "<%rsex%>";
  numeric i, on;
  do i = 1 while i <= teamMemberCount by 1    
    UID = teamIdIndex(teamIds(i));
    if loadcase(USERS_DICT, UID) then
      if teamIds(i) <> tonumber(InterviewerId) then // exclure l'enqueteur actuel 
        on = 10000 + UNUMBER; // ajouter 10000 au numéro de membre de l'équipe pour éviter toute collision avec d'autres options sur le menu ou sur la liste de tâches
        
        addMenuOption(maketext(".%d:%d %s", on, UNUMBER, strip(UNAME)));
        
        // configuration des options de délégation dynamique pour les tâches
        setOption("intTasks", on, maketext("%d %s", UNUMBER, strip(UNAME)), "", maketext("ig_%d==9 | %s==9 | ig_%d==%s", UNUMBER, rSex, UNUMBER, rSex));
        optionsStr = maketext("%s%d,", optionsStr, on);
      endif;
    endif;
  enddo;

// arborescence des options de réglage pour les tâches "délégué"
  if length(optionsStr) > 1 then
    optionsStr = optionsStr[1:length(optionsStr) - 1] + "}";
    
    // NAB  le construire en conformité avec le template
    
    setOptionsTree("intTasks", "mod01_int", 1,  "{241,245" + optionsStr + "}");
    setOptionsTree("intTasks", "mod19_int", 1,  "{5,9" + optionsStr + "}");
    setOptionsTree("intTasks", "mod16_int", 1,  "{11,15 " + optionsStr + "}");
    setOptionsTree("intTasks", "mod20_int", 1,  "{17,21 " + optionsStr + "}");
    setOptionsTree("intTasks", "mod08_int", 1,  "{23,27 " + optionsStr + "}");
    setOptionsTree("intTasks", "mod07_int", 1,  "{29,33 " + optionsStr + "}");
    setOptionsTree("intTasks", "mod21_int", 1,  "{101,105 " + optionsStr + "}");
    setOptionsTree("intTasks", "mod22_int", 1,  "{107,111 " + optionsStr + "}");
    setOptionsTree("intTasks", "mod23_int", 1,  "{113,117 " + optionsStr + "}");
    setOptionsTree("intTasks", "mod24_int", 1,  "{119,123 " + optionsStr + "}");
    setOptionsTree("intTasks", "mod26_int", 1,  "{131,135 " + optionsStr + "}");
    setOptionsTree("intTasks", "mod14_int", 1,  "{83,87" + optionsStr + "}");
    setOptionsTree("intTasks", "mod12_int", 1,  "{71,75 " + optionsStr + "}");
    setOptionsTree("intTasks", "mod27_int", 1,  "{137,141 " + optionsStr + "}");
    setOptionsTree("intTasks", "mod28_int", 1,  "{143,147 " + optionsStr + "}");
    setOptionsTree("intTasks", "mod29_int", 1,  "{149,153 " + optionsStr + "}");
    setOptionsTree("intTasks", "mod13_int", 1,  "{77,81 " + optionsStr + "}");
    setOptionsTree("intTasks", "mod18_int", 1,  "{95,99 " + optionsStr + "}");   
    setOptionsTree("intTasks", "mod11_int", 1,  "{65,69 " + optionsStr + "}");
    setOptionsTree("intTasks", "mod30_int", 1,  "{155,159 " + optionsStr + "}");
    setOptionsTree("intTasks", "mod31_int", 1,  "{161,165 " + optionsStr + "}");
    setOptionsTree("intTasks", "mod32_int", 1,  "{167,171 " + optionsStr + "}");
    setOptionsTree("intTasks", "mod15_int", 1,  "{89,93 " + optionsStr + "}");
    setOptionsTree("intTasks", "mod09_int", 1,  "{53,57 " + optionsStr + "}");
    setOptionsTree("intTasks", "mod17_int", 1,  "{35,39 " + optionsStr + "}");
    setOptionsTree("intTasks", "mod33_int", 1,  "{173,177 " + optionsStr + "}");
    setOptionsTree("intTasks", "mod06_int", 1,  "{47,51 " + optionsStr + "}");
    setOptionsTree("intTasks", "mod34_int", 1,  "{179,183 " + optionsStr + "}");
    setOptionsTree("intTasks", "mod10_int", 1,  "{59,63 " + optionsStr + "}");
    setOptionsTree("intTasks", "mod35_int", 1,  "{185,189 " + optionsStr + "}");
    setOptionsTree("intTasks", "mod25_int", 1,  "{125,129 " + optionsStr + "}");
    setOptionsTree("intTasks", "mod37_int", 1,  "{191,195 " + optionsStr + "}");


  endif;
  
  addMenuOption("3:Changer de grappe"); //!T
  addMenuOption("4:textcolor=#467386;;;Quitter"); //!T
  
// recharger l'intervieweur actuel
  UID = btAddress;
  loadcase(USERS_DICT, btAddress);
  
// sauvegarde le numéro de cluster dans le tableau d'état à l'index '1'
  state(1) = MCLUST;
  savePreviousValues();
  
// montrant le menu
  while 1 do
    // traitement des paquets entrants. Besoin de synchroniser les données entre l'intervieweur et le superviseur sur la même machine
    procIncoming("1:" + edit("99999", tonumber(InterviewerId)), RepDict + "\tasks.dcf");
    setMenuColors(syncIdx);
    numeric x = showMenu("Choisir une option");
    if x = 1 then //les tâches
      while 1 do
      	updateTasks();
		numeric x1 = showTasks();
        if x1 = 0 then break; endif;
        taskrouter(x1);
      enddo;
      
    elseif x = 3  | x = 9999 then //choisir une autre grappe
      reenter;
    elseif x = 4 then //quitter
      exitEnvironment();
      stop(-1);
    elseif x >= 10000 then //synchronisation
      btSync(x - 10000);
      checkUpdates();
    endif;
  enddo;
