{Application 'MODULE30' logic file generated by CSPro}
PROC GLOBAL
set explicit ;
alpha(26) alphavar;				   { Alpha working variable used in checking alpha vars }
alpha(26) alphanew;                { Alpha working variable used in checking alpha vars }
alpha(62) alphalst;                { The alphabet }
numeric x;

function alphachk(alpha(26) alphamask);
{  russian_convert();}
  { first remove all blanks, and duplicate question marks }
  alphanew = "";
 numeric  qmark = 0;
 numeric  lx = 1  l  a ;
  do l = 1 while l <= length(strip(alphavar))
    if alphavar[l:1] <> " " and (alphavar[l:1] <> "?" or not qmark) then
      alphanew[lx:1] = alphavar[l:1];
      lx = lx + 1;
      if alphavar[l:1] = "?" then
        qmark = 1;
      endif;
    endif;
  enddo;
  { aok = 0 - string is bad, aok = 1 - string is good }
numeric   totlen = length(strip(alphamask));
 numeric  aok = 0;           { assume string is bad - for empty string }
 numeric alphsize = length(strip(alphanew));
  if alphsize then   { not empty string }
    { check for "?" as only character }
    aok = (alphanew[1:1] = "?" and alphsize = 1);
    if !aok then     { if not a single "?", check string }
      aok = 1;       { now assume string is good until we know otherwise }
      l = 1;         { l is position in string of acceptable values }
      a = 1;         { a is position in input string }
      { loop while the string is still good and there are more letters }
      while aok and a <= alphsize do
        aok = pos(alphanew[a:1],alphamask[l:totlen-l+1]);
        if aok then     { letter is acceptable }
          l = l + aok;  { increment l to position after letter in string of acceptable values }
          a = a + 1     { increment a to next letter in input string }
        endif;
      enddo;
    endif;
  endif;
  alphachk = (!aok);    { alphachk = 0 - if string is good, = 1 - if string is bad }
  { now expand variables }
  if aok then
    do l = 1 while l <= length(strip(alphamask))
      if pos(alphamask[l:1],alphanew) then
        alphavar[l:1] = alphamask[l:1]
      elseif pos("?",alphanew) then
        alphavar[l:1] = "?"
      else
        alphavar[l:1] = " "
      endif;
    enddo;
  endif;
end;


PROC EPMU1M30_FF

PROC M301


 errmsg("ERREURS DU MODULE 30 : IMPOTS ET TAXES AU COURS DES 12 DERNIERS MOIS  ");
 errmsg("======================================================================");
PROC M3011

x = totocc(IMPOTS_EDT) ;

  if $ <> 1 then
	    if x > 0 then
	    	errmsg(117001,M301,M302,30,"M3011",M30INT);
	    endif;
  endif;
PROC IMPQ01

if $ <> x and X > 0 then 
	errmsg(027001,M301,M302,30,"IMPQ01",M30INT,$,x);
endif;
PROC IMPQ03

if M30TYPE = 1 and not invalueset(IMPQ03, IMPQ03_VS1) then
	errmsg(030001,M301,M302,30,"IMPQ03",M30INT,IMPQ02);
endif;



PROC IMPQ04

if $<> notappl and $ < 1000 then
	errmsg(040001,M301,M302,30,"IMPQ04",M30INT,$,IMPQ02);
endif;
	
if $<> notappl and $%50 <> 0  then
	errmsg(040002,M301,M302,30,"IMPQ04",M30INT,$,IMPQ02);
endif;
PROC IMPQ05

if $<> notappl and $ < 1000 then
	errmsg(050001,M301,M302,30,"IMPQ05",M30INT,$)
endif;
	
if $<> notappl and $%50 <> 0  then
	errmsg(050002,M301,M302,30,"IMPQ05",M30INT,$);
endif;

if IMPQ05 < IMPQ04 then
	errmsg(050003,M301,M302,30,"IMPQ05",M30INT,$,IMPQ04);
endif;

PROC IMPQ07

if not invalueset(IMPQ07, IMPQ07_VS1) and special($) then
	errmsg(070001,M301,M302,30,"IMPQ07",M30INT,IMPQ02);
endif;
